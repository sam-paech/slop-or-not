<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Writing Metrics: Slop • Repetition • Contrast • Top n-grams</title>
<style>
  :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa4ad; --card:#171a21; --accent:#6aa0ff; }
  * { box-sizing: border-box; }
  body { margin: 0; padding: 24px; background: var(--bg); color: var(--fg); font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
  h1 { font-size: 18px; margin: 0 0 12px; }
  .row { display: grid; grid-template-columns: 1fr 380px; gap: 18px; }
  textarea { width: 100%; height: 50vh; padding: 12px; background: var(--card); color: var(--fg); border: 1px solid #2a2f3a; border-radius: 8px; resize: vertical; }
  button { background: var(--accent); color: #0b0f16; border: 0; border-radius: 8px; padding: 10px 14px; font-weight: 600; cursor: pointer; }
  button:disabled { opacity: .55; cursor: not-allowed; }
  button.show-more { background: transparent; color: var(--accent); padding: 6px 10px; font-size: 12px; margin-top: 6px; border: 1px solid var(--accent); }
  button.show-more:hover { background: var(--accent); color: var(--bg); }
  .panel { background: var(--card); border: 1px solid #2a2f3a; border-radius: 8px; padding: 12px 14px; }
  .muted { color: var(--muted); }
  .metric { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 6px 0; border-bottom: 1px dashed #2a2f3a; }
  .metric:last-child { border-bottom: 0; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .section { margin-top: 16px; }
  .pill { display: inline-block; background: #10141c; border: 1px solid #2a2f3a; border-radius: 999px; padding: 4px 8px; margin: 4px 6px 0 0; font-size: 12px; }
  .pill b { color: #b8c7ff; }
  .contrast-match { background: #1a1f2a; border: 1px solid #3a4f5a; border-radius: 6px; padding: 8px 10px; margin: 6px 0; font-size: 12px; }
  .contrast-match .pattern { color: #8a9aaa; font-size: 10px; margin-bottom: 4px; }
  details { margin-top: 10px; }
  summary { cursor: pointer; color: #c7d5ff; }
  code { background: #10141c; padding: 2px 6px; border-radius: 6px; }

  /* Leaderboard styles */
  #leaderboard { display: none; width: 100%; }
  #leaderboard.visible { display: block; }
  .leaderboard-row { display: flex; align-items: center; gap: 10px; padding: 10px; margin: 6px 0; background: var(--card); border: 1px solid #2a2f3a; border-radius: 6px; transition: all 0.3s ease; position: relative; }
  .leaderboard-row.user-result { background: #1a2533; border: 2px solid var(--accent); animation: slideIn 0.5s ease-out; }
  @keyframes slideIn {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
  }
  .leaderboard-rank { font-weight: 700; color: var(--accent); min-width: 30px; }
  .leaderboard-name { flex: 0 0 200px; font-size: 13px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .leaderboard-bar-container { flex: 1; height: 24px; background: #10141c; border-radius: 4px; position: relative; overflow: hidden; }
  .leaderboard-bar { height: 100%; background: linear-gradient(90deg, #3a7fff 0%, #6aa0ff 100%); border-radius: 4px; transition: width 0.6s ease-out; }
  .leaderboard-bar.user-bar { background: linear-gradient(90deg, #ff9d3a 0%, #ffb66a 100%); }
  .leaderboard-score { min-width: 60px; text-align: right; font-weight: 600; font-family: var(--mono); }
  .leaderboard-report-btn { background: transparent; border: 1px solid #3a4f5a; padding: 4px 8px; font-size: 11px; cursor: pointer; color: var(--accent); border-radius: 4px; }
  .leaderboard-report-btn:hover { background: var(--accent); color: var(--bg); }

  /* Modal styles */
  .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; }
  .modal.visible { display: flex; }
  .modal-content { background: var(--card); border: 1px solid #3a4f5a; border-radius: 8px; padding: 20px; max-width: 600px; max-height: 80vh; overflow-y: auto; }
  .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
  .modal-close { background: transparent; color: var(--muted); cursor: pointer; font-size: 24px; border: none; padding: 0; }
  .modal-close:hover { color: var(--fg); }
  .modal-metric { display: grid; grid-template-columns: 1fr auto; gap: 12px; padding: 8px 0; border-bottom: 1px solid #2a2f3a; }
  .modal-metric:last-child { border-bottom: none; }

  button.secondary { background: transparent; border: 1px solid var(--accent); color: var(--accent); margin-left: 10px; }
  button.secondary:hover { background: var(--accent); color: var(--bg); }
</style>
</head>
<body>
  <h1>Writing Metrics</h1>
  <div class="row">
    <div>
      <textarea id="input" placeholder="Paste or type your long-form text here…"></textarea>
      <div id="leaderboard"></div>
      <div class="section">
        <button id="analyzeBtn" disabled>Analyze</button>
        <button id="viewLeaderboardBtn" class="secondary">View Leaderboard</button>
        <button id="newTextBtn" class="secondary" style="display:none;">Analyse New Text</button>
        <span id="status" class="muted" style="margin-left:10px;">loading resources…</span>
      </div>
      <div id="errors" class="section mono" style="white-space:pre-wrap;color:#ffb4b4;"></div>
    </div>
    <div class="panel">
      <div class="metric"><div>Total characters</div><div id="m_chars" class="mono">—</div></div>
      <div class="metric"><div>Total words</div><div id="m_words" class="mono">—</div></div>
      <div class="metric"><div>Slop index (per 1k words)</div><div id="m_slop" class="mono">—</div></div>
      <div class="metric"><div>Repetition score (%)</div><div id="m_rep" class="mono">—</div></div>
      <div class="metric"><div>Contrast patterns (per 1k chars)</div><div id="m_contrast" class="mono">—</div></div>

      <div class="section">
        <details open>
          <summary>Top over-represented words</summary>
          <div id="topWords" style="margin-top:8px;"></div>
        </details>
        <details open>
          <summary>Top bigrams (over-use vs human)</summary>
          <div id="topBigrams" style="margin-top:8px;"></div>
        </details>
        <details open>
          <summary>Top trigrams (over-use vs human)</summary>
          <div id="topTrigrams" style="margin-top:8px;"></div>
        </details>
        <details>
          <summary>Contrast patterns ("not X, but Y")</summary>
          <div id="contrastMatches" style="margin-top:8px;"></div>
        </details>
        <details>
          <summary>Exact repeated phrases (trigram-based)</summary>
          <div id="topPhrases" style="margin-top:8px;"></div>
        </details>
      </div>
      <div class="section muted" style="font-size:12px;">
        Resources in <code>data/</code>: <code>human_writing_profile.json</code>, <code>slop_list.json</code>, <code>slop_list_bigrams.json</code>, <code>slop_list_trigrams.json</code>.
      </div>
    </div>
  </div>

  <!-- Modal for detailed stats -->
  <div id="detailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 style="margin:0;">Detailed Report</h2>
        <button class="modal-close" id="closeModal">&times;</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

<script type="module">
import { wordsOnlyLower, alphaTokens, countItems } from './js/utils.js';
import {
  loadSUBTLEX,
  loadHumanProfile,
  loadSlopSets,
  computeSlopIndex,
  contentTokens,
  makeNgrams,
  rankOveruseWithCounts,
  extractRepeatedPhrases,
  lookupZipf,
  humanBigramFreq,
  humanTrigramFreq
} from './js/metrics.js';
import { initPosTagger } from './js/pos-tagger.js';
import { scoreText as scoreContrast } from './js/contrast-detector.js';

const ui = {
  btn: document.getElementById('analyzeBtn'),
  status: document.getElementById('status'),
  errors: document.getElementById('errors'),
  input: document.getElementById('input'),
  leaderboard: document.getElementById('leaderboard'),
  viewLeaderboardBtn: document.getElementById('viewLeaderboardBtn'),
  newTextBtn: document.getElementById('newTextBtn'),
  m_chars: document.getElementById('m_chars'),
  m_words: document.getElementById('m_words'),
  m_slop: document.getElementById('m_slop'),
  m_rep: document.getElementById('m_rep'),
  m_contrast: document.getElementById('m_contrast'),
  topWords: document.getElementById('topWords'),
  topBigrams: document.getElementById('topBigrams'),
  topTrigrams: document.getElementById('topTrigrams'),
  contrastMatches: document.getElementById('contrastMatches'),
  topPhrases: document.getElementById('topPhrases'),
  modal: document.getElementById('detailModal'),
  modalBody: document.getElementById('modalBody'),
  closeModal: document.getElementById('closeModal'),
};

let ready = false;
let leaderboardData = null;
let normalizationRanges = null;
let userResult = null;

function renderPills(targetEl, items, fmt = (w, v) => `<b>${w}</b> <span class="muted">(${v})</span>`, showLimit = 10) {
  if (!items.length) {
    targetEl.innerHTML = '<span class="muted">None found</span>';
    return;
  }

  const visibleItems = items.slice(0, showLimit);
  const hiddenItems = items.slice(showLimit);

  let html = visibleItems.map(([w, v]) => `<span class="pill">${fmt(w, v)}</span>`).join("");

  if (hiddenItems.length > 0) {
    const toggleId = 'toggle_' + Math.random().toString(36).substr(2, 9);
    html += `<div id="${toggleId}_hidden" style="display:none;">`;
    html += hiddenItems.map(([w, v]) => `<span class="pill">${fmt(w, v)}</span>`).join("");
    html += `</div>`;
    html += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenItems.length} more</button>`;

    targetEl.innerHTML = html;

    // Add click handler
    const btn = document.getElementById(`${toggleId}_btn`);
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      btn.textContent = expanded ? 'Show less' : `Show ${hiddenItems.length} more`;
    });
  } else {
    targetEl.innerHTML = html;
  }
}

function renderContrastMatches(targetEl, matches, showLimit = 10) {
  if (!matches.length) {
    targetEl.innerHTML = '<span class="muted">None found</span>';
    return;
  }

  const visibleMatches = matches.slice(0, showLimit);
  const hiddenMatches = matches.slice(showLimit);

  let html = visibleMatches.map(m =>
    `<div class="contrast-match">
      <div class="pattern">${m.pattern_name}</div>
      <div>${m.sentence}</div>
    </div>`
  ).join("");

  if (hiddenMatches.length > 0) {
    const toggleId = 'toggle_' + Math.random().toString(36).substr(2, 9);
    html += `<div id="${toggleId}_hidden" style="display:none;">`;
    html += hiddenMatches.map(m =>
      `<div class="contrast-match">
        <div class="pattern">${m.pattern_name}</div>
        <div>${m.sentence}</div>
      </div>`
    ).join("");
    html += `</div>`;
    html += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenMatches.length} more</button>`;

    targetEl.innerHTML = html;

    const btn = document.getElementById(`${toggleId}_btn`);
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      btn.textContent = expanded ? 'Show less' : `Show ${hiddenMatches.length} more`;
    });
  } else {
    targetEl.innerHTML = html;
  }
}

// Leaderboard functions
async function loadLeaderboard() {
  const response = await fetch('data/leaderboard_results.json');
  const data = await response.json();
  leaderboardData = data.results;

  // Compute normalization ranges with 10% buffer
  const slopVals = leaderboardData.map(r => r.metrics.slop_list_matches_per_1k_words);
  const ngramVals = leaderboardData.map(r => r.metrics.ngram_repetition_score);
  const contrastVals = leaderboardData.map(r => r.metrics.not_x_but_y_per_1k_chars);

  const computeRange = (values) => {
    const min = Math.min(...values);
    const max = Math.max(...values);
    const range = max - min;
    return {
      min: min - range * 0.1,
      max: max + range * 0.1
    };
  };

  normalizationRanges = {
    slop: computeRange(slopVals),
    ngram: computeRange(ngramVals),
    contrast: computeRange(contrastVals)
  };

  console.log('Normalization ranges:', normalizationRanges);
}

function normalizeValue(value, range) {
  const normalized = (value - range.min) / (range.max - range.min);
  return Math.max(0, Math.min(1, normalized));
}

function computeSlopScore(slopIndex, ngramScore, contrastScore) {
  const normSlop = normalizeValue(slopIndex, normalizationRanges.slop);
  const normNgram = normalizeValue(ngramScore, normalizationRanges.ngram);
  const normContrast = normalizeValue(contrastScore, normalizationRanges.contrast);

  return ((normSlop + normNgram + normContrast) / 3) * 1000;
}

function renderLeaderboard(includeUserResult = false) {
  // Compute slop scores for all leaderboard entries
  const entries = leaderboardData.map(entry => ({
    model: entry.model,
    slopScore: computeSlopScore(
      entry.metrics.slop_list_matches_per_1k_words,
      entry.metrics.ngram_repetition_score,
      entry.metrics.not_x_but_y_per_1k_chars
    ),
    fullData: entry
  }));

  // Add user result if available
  if (includeUserResult && userResult) {
    entries.push({
      model: 'Your Text',
      slopScore: userResult.slopScore,
      fullData: userResult.fullData,
      isUser: true
    });
  }

  // Sort by slop score (lower is better)
  entries.sort((a, b) => a.slopScore - b.slopScore);

  // Find max score for bar width calculation
  const maxScore = Math.max(...entries.map(e => e.slopScore));

  // Render
  let html = '<h2 style="margin-bottom: 12px;">Leaderboard</h2>';
  entries.forEach((entry, idx) => {
    const barWidth = (entry.slopScore / maxScore) * 100;
    const rowClass = entry.isUser ? 'leaderboard-row user-result' : 'leaderboard-row';
    const barClass = entry.isUser ? 'leaderboard-bar user-bar' : 'leaderboard-bar';

    html += `
      <div class="${rowClass}">
        <div class="leaderboard-rank">${idx + 1}</div>
        <div class="leaderboard-name" title="${entry.model}">${entry.model}</div>
        <div class="leaderboard-bar-container">
          <div class="${barClass}" style="width: ${barWidth}%"></div>
        </div>
        <div class="leaderboard-score">${entry.slopScore.toFixed(1)}</div>
        <button class="leaderboard-report-btn" data-model="${entry.model}">Report</button>
      </div>
    `;
  });

  ui.leaderboard.innerHTML = html;

  // Add event listeners to report buttons
  ui.leaderboard.querySelectorAll('.leaderboard-report-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const model = e.target.dataset.model;
      const entry = entries.find(e => e.model === model);
      showDetailModal(entry);
    });
  });
}

function showDetailModal(entry) {
  const data = entry.fullData;

  let html = `<h3>${entry.model}</h3>`;

  if (data.metrics) {
    html += `
      <div class="modal-metric">
        <div>Slop Score</div>
        <div class="mono">${entry.slopScore.toFixed(2)}</div>
      </div>
      <div class="modal-metric">
        <div>Slop List Matches (per 1k words)</div>
        <div class="mono">${data.metrics.slop_list_matches_per_1k_words.toFixed(2)}</div>
      </div>
      <div class="modal-metric">
        <div>N-gram Repetition Score</div>
        <div class="mono">${data.metrics.ngram_repetition_score.toFixed(4)}</div>
      </div>
      <div class="modal-metric">
        <div>Contrast Patterns (per 1k chars)</div>
        <div class="mono">${data.metrics.not_x_but_y_per_1k_chars.toFixed(2)}</div>
      </div>
    `;

    if (data.metrics.lexical_diversity) {
      html += `
        <h4 style="margin-top: 16px;">Lexical Diversity</h4>
        <div class="modal-metric">
          <div>MATTR-500</div>
          <div class="mono">${data.metrics.lexical_diversity.mattr_500.toFixed(4)}</div>
        </div>
        <div class="modal-metric">
          <div>Type-Token Ratio</div>
          <div class="mono">${data.metrics.lexical_diversity.type_token_ratio.toFixed(4)}</div>
        </div>
        <div class="modal-metric">
          <div>Unique Words</div>
          <div class="mono">${data.metrics.lexical_diversity.unique_words.toLocaleString()}</div>
        </div>
        <div class="modal-metric">
          <div>Total Words</div>
          <div class="mono">${data.metrics.lexical_diversity.total_words.toLocaleString()}</div>
        </div>
      `;
    }

    if (data.sample_count) {
      html += `
        <h4 style="margin-top: 16px;">Sample Info</h4>
        <div class="modal-metric">
          <div>Sample Count</div>
          <div class="mono">${data.sample_count}</div>
        </div>
        <div class="modal-metric">
          <div>Total Characters</div>
          <div class="mono">${data.total_chars.toLocaleString()}</div>
        </div>
      `;
    }

    if (data.top_over_represented && data.top_over_represented.words) {
      html += `
        <h4 style="margin-top: 16px;">Top Over-represented Words</h4>
        <div style="margin-top: 8px;">
      `;
      data.top_over_represented.words.slice(0, 10).forEach(w => {
        html += `<span class="pill"><b>${w.word}</b> <span class="muted">${w.ratio.toFixed(2)}×</span></span>`;
      });
      html += `</div>`;
    }
  }

  ui.modalBody.innerHTML = html;
  ui.modal.classList.add('visible');
}

function hideLeaderboard() {
  ui.leaderboard.classList.remove('visible');
  ui.input.style.display = 'block';
  ui.viewLeaderboardBtn.style.display = 'inline-block';
  ui.newTextBtn.style.display = 'none';
}

function showLeaderboard() {
  ui.input.style.display = 'none';
  ui.leaderboard.classList.add('visible');
  ui.viewLeaderboardBtn.style.display = 'none';
  ui.newTextBtn.style.display = 'inline-block';
  renderLeaderboard(userResult !== null);
}

async function init() {
  let posLoaded = false;

  try {
    // Try to load POS tagger (optional for Stage2 patterns)
    ui.status.textContent = "loading POS tagger…";
    try {
      await initPosTagger();
      posLoaded = true;
      console.log('✓ POS tagger loaded - Stage2 patterns enabled');
    } catch (posError) {
      console.warn('POS tagger failed to load:', posError.message);
      console.warn('⚠ Stage2 contrast patterns will be disabled. Stage1 patterns will still work.');
      // Continue without POS tagger
    }

    ui.status.textContent = "loading SUBTLEX…";
    await loadSUBTLEX();

    ui.status.textContent = "loading resources…";
    await Promise.all([loadHumanProfile(), loadSlopSets(), loadLeaderboard()]);

    ready = true;
    const statusMsg = posLoaded
      ? "ready (Stage1 + Stage2 patterns)"
      : "ready (Stage1 patterns only - POS tagger unavailable)";
    ui.status.textContent = statusMsg;

    if (!posLoaded) {
      ui.errors.textContent = "⚠ Note: POS tagger could not be loaded. Stage2 contrast patterns are disabled, but Stage1 patterns will still work.";
    }

    ui.btn.disabled = false;
  } catch (e) {
    ui.status.textContent = "CRITICAL ERROR";
    const errorMsg = String(e?.message || e);
    ui.errors.textContent = `❌ ${errorMsg}\n\nThe application cannot function without this component. Please check:\n1. Your internet connection\n2. Browser console for details\n3. Whether CDN services are accessible`;
    console.error('Initialization failed:', e);
    // Keep button disabled on critical errors
    ui.btn.disabled = true;
  }
}

ui.btn.addEventListener('click', () => {
  if (!ready) return;
  ui.errors.textContent = "";

  const raw = ui.input.value || "";
  const chars = raw.length;
  const toks0 = wordsOnlyLower(raw);
  const toks = alphaTokens(toks0);
  const nWords = toks.length;

  ui.m_chars.textContent = chars.toLocaleString();
  ui.m_words.textContent = nWords.toLocaleString();

  // Slop
  const slop = computeSlopIndex(toks);
  ui.m_slop.textContent = slop.toFixed(2);

  // Repetition score
  const toksContent = contentTokens(toks);
  const bigs = makeNgrams(toksContent, 2);
  const tris = makeNgrams(toksContent, 3);

  const topBCounts = rankOveruseWithCounts(bigs, humanBigramFreq, 40);
  const topTCounts = rankOveruseWithCounts(tris, humanTrigramFreq, 40);

  const top_bigram_count = topBCounts.reduce((s, r) => s + r[2], 0);
  const top_trigram_count = topTCounts.reduce((s, r) => s + r[2], 0);
  const total_text_length = toks.length;

  const repetition_score =
    total_text_length > 0
      ? ((top_bigram_count + top_trigram_count) / total_text_length) * 1000
      : 0;

  ui.m_rep.textContent = repetition_score.toFixed(4);

  // Contrast patterns
  const contrastResult = scoreContrast(raw);
  ui.m_contrast.textContent = contrastResult.rate_per_1k.toFixed(2);
  renderContrastMatches(ui.contrastMatches, contrastResult.matches, 10);

  // Compute slop score for user text
  const userSlopScore = computeSlopScore(slop, repetition_score, contrastResult.rate_per_1k);

  // Store user result
  userResult = {
    slopScore: userSlopScore,
    fullData: {
      metrics: {
        slop_list_matches_per_1k_words: slop,
        ngram_repetition_score: repetition_score,
        not_x_but_y_per_1k_chars: contrastResult.rate_per_1k
      }
    }
  };

  // Top over-represented words (vs Zipf baseline)
  const wordCounts = countItems(toksContent);
  const wordOverrep = [];
  for (const [w, cnt] of wordCounts.entries()) {
    const zipf = lookupZipf(w);
    if (zipf === null) continue;
    const expected = Math.pow(10, zipf - 3);
    const actual = (cnt / nWords) * 1000;
    const ratio = actual / (expected + 1e-9);
    if (ratio > 1.5 && cnt >= 2) {
      wordOverrep.push([w, ratio, cnt]);
    }
  }
  wordOverrep.sort((a, b) => b[1] - a[1]);
  const topWords = wordOverrep.slice(0, 40);
  renderPills(
    ui.topWords,
    topWords.map(([w, ratio, cnt]) => [w, Number(ratio.toFixed(2))]),
    (w, v) => `<b>${w}</b> <span class="muted">${v}×</span>`,
    10
  );

  // Top bigrams and trigrams
  renderPills(
    ui.topBigrams,
    topBCounts.map(([w, ratio]) => [w, Number(ratio.toFixed(2))]),
    (w, v) => `<b>${w}</b> <span class="muted">${v}×</span>`,
    10
  );
  renderPills(
    ui.topTrigrams,
    topTCounts.map(([w, ratio]) => [w, Number(ratio.toFixed(2))]),
    (w, v) => `<b>${w}</b> <span class="muted">${v}×</span>`,
    10
  );

  // Exact phrases
  const topT = topTCounts.map(([ng, ratio, cnt]) => [ng, ratio]);
  const phrases = extractRepeatedPhrases(raw, topT, 300);
  renderPills(ui.topPhrases, phrases, (w, v) => `<b>${w}</b> <span class="muted">(${v})</span>`, 10);

  // Show leaderboard after analysis
  showLeaderboard();
});

// Button event listeners
ui.viewLeaderboardBtn.addEventListener('click', () => {
  showLeaderboard();
});

ui.newTextBtn.addEventListener('click', () => {
  hideLeaderboard();
  userResult = null;
});

ui.closeModal.addEventListener('click', () => {
  ui.modal.classList.remove('visible');
});

ui.modal.addEventListener('click', (e) => {
  if (e.target === ui.modal) {
    ui.modal.classList.remove('visible');
  }
});

// Prefill for quick testing
ui.input.value = `The silence wasn't empty. It wasn't absence; it was pressure. Not a pause—but a held breath.
For the first time in years, the quiet felt shared. The lattice rose, not just as metal, but as intention.`;

init();
</script>
</body>
</html>
