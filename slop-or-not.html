<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Slop-or-Not | EQ-Bench</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<style>
  :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa4ad; --card:#171a21; --accent:#6aa0ff; }
  * { box-sizing: border-box; }
  body { margin: 0; padding: 0; background: var(--bg); color: var(--fg); }

  /* Container */
  .container { max-width: 1400px; margin: 0 auto; padding: 24px; background: var(--bg); }

  /* EQBench header styles */
  .header { display: flex; align-items: flex-end; margin-bottom: 10px; }
  .logo { width: 100px; height: auto; margin-right: 10px; }
  .header-text h1, .header-text p { margin: 0; }

  /* Dark mode toggle */
  .form-check { position: fixed; top: 10px; right: 10px; z-index: 1000; }
  #toggleLabel { margin-right: 8px; }

  /* Navigation styles */
  .nav-separator { color: var(--muted); margin: 0 4px; }
  .nav-dropdown { position: relative; display: inline-block; }
  .nav-dropdown-toggle {
    background: none;
    border: none;
    padding: 0;
    font: inherit;
    color: #007bff;
    cursor: pointer;
    text-decoration: none;
  }
  .nav-dropdown-toggle:hover { text-decoration: underline; }
  .nav-dropdown-toggle::after { content: ' ▾'; font-size: 0.8em; }

  body.dark-mode .nav-dropdown-toggle { color: #4dabf7; }

  .nav-dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    left: 0;
    margin-top: 8px;
    padding: 8px 0;
    background: #ffffff;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    border-radius: 4px;
    min-width: 200px;
    z-index: 1000;
  }
  .nav-dropdown-menu.show { display: block; }
  .nav-dropdown-item {
    display: block;
    padding: 8px 16px;
    color: inherit;
    text-decoration: none;
    white-space: nowrap;
  }
  .nav-dropdown-item:hover {
    background: rgba(0, 0, 0, 0.05);
    color: inherit;
    text-decoration: none;
  }

  body.dark-mode .nav-dropdown-menu {
    background: #1a1a1a;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
  }
  body.dark-mode .nav-dropdown-item:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  /* Slop-specific content font (not applied to header/nav) */
  .slop-content {
    font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
    margin-top: 24px;
  }

  .slop-content > .section:first-child {
    margin-top: 0;
    padding: 0;
  }

  /* Light mode base styles */
  body.dark-mode { background: var(--bg); color: var(--fg); }
  body.dark-mode .container { background: var(--bg); }
  .row { display: grid; grid-template-columns: 1fr 380px; gap: 18px; align-items: start; }
  .row > div:first-child { min-height: 0; }
  textarea { width: 100%; height: 50vh; padding: 12px; background: var(--card); color: var(--fg); border: 1px solid #2a2f3a; border-radius: 8px; resize: vertical; }
  button { background: var(--accent); color: #0b0f16; border: 0; border-radius: 8px; padding: 10px 14px; font-weight: 600; cursor: pointer; }
  button:disabled { opacity: .55; cursor: not-allowed; }
  button.show-more { background: transparent; color: var(--accent); padding: 6px 10px; font-size: 12px; margin-top: 6px; border: 1px solid var(--accent); }
  button.show-more:hover { background: var(--accent); color: var(--bg); }

  /* Light mode: show-more buttons - minimalist b&w */
  body:not(.dark-mode) button.show-more {
    background: #ffffff;
    color: #222;
    border: 1px solid #ccc;
  }
  body:not(.dark-mode) button.show-more:hover {
    background: #f0f0f0;
    color: #222;
    border: 1px solid #999;
  }
  .panel { background: var(--card); border: 1px solid #2a2f3a; border-radius: 8px; padding: 12px 14px; }
  .muted { color: var(--muted); }
  .metric { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 6px 0; border-bottom: 1px dashed #2a2f3a; }
  .metric:last-child { border-bottom: 0; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .section { margin-top: 16px; }
  .pill { display: inline-block; background: #10141c; border: 1px solid #2a2f3a; border-radius: 999px; padding: 4px 8px; margin: 4px 6px 0 0; font-size: 12px; }
  .pill b { color: #e6e6e6; }
  .contrast-match { background: #1a1f2a; border: 1px solid #3a4f5a; border-radius: 6px; padding: 12px 16px 12px 40px; margin: 6px 0; font-size: 13px; position: relative; line-height: 1.6; }
  .contrast-match::before { content: '\201C'; position: absolute; left: 8px; top: 4px; font-size: 48px; color: #3a4f5a; opacity: 0.4; font-family: Georgia, serif; line-height: 1; }
  details { margin-top: 10px; }
  summary { cursor: pointer; color: #c7d5ff; }
  code { background: #10141c; padding: 2px 6px; border-radius: 6px; }

  /* Leaderboard styles */
  #leaderboard { display: none; width: 100%; }
  #leaderboard.visible { display: block; }
  .leaderboard-row { display: flex; align-items: center; gap: 10px; padding: 10px; margin: 6px 0; background: var(--card); border: 1px solid #2a2f3a; border-radius: 6px; transition: all 0.3s ease; position: relative; }
  .leaderboard-row.user-result { animation: slideIn 0.5s ease-out; }
  .leaderboard-row.user-result .leaderboard-name { font-weight: 700; }
  @keyframes slideIn {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
  }
  .leaderboard-rank { font-weight: 700; color: var(--accent); min-width: 30px; }
  .leaderboard-name { flex: 0 0 200px; font-size: 13px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .leaderboard-bar-container { flex: 1; height: 24px; background: #10141c; border-radius: 4px; position: relative; overflow: hidden; }
  .leaderboard-bar { height: 100%; background: linear-gradient(90deg, #6fd147 0%, #8fe66a 100%); border-radius: 4px; transition: width 0.6s ease-out; }
  .leaderboard-bar.user-bar { background: linear-gradient(90deg, #ff9d3a 0%, #ffb66a 100%); }
  .leaderboard-score { min-width: 60px; text-align: right; font-weight: 600; font-family: var(--mono); }
  .leaderboard-report-btn { background: transparent; border: 1px solid #3a4f5a; padding: 4px 8px; font-size: 11px; cursor: pointer; color: var(--accent); border-radius: 4px; }
  .leaderboard-report-btn:hover { background: var(--accent); color: var(--bg); }

  /* Modal styles */
  .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); align-items: center; justify-content: center; }
  .modal.visible { display: flex; }
  .modal-content { background: var(--card); border: 1px solid #3a4f5a; border-radius: 8px; padding: 20px; max-width: 600px; max-height: 80vh; overflow-y: auto; }
  .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
  .modal-close { background: transparent; color: var(--muted); cursor: pointer; font-size: 24px; border: none; padding: 0; }
  .modal-close:hover { color: var(--fg); }
  .modal-metric { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; border-bottom: 1px solid #2a2f3a; position: relative; }
  .modal-metric:last-child { border-bottom: none; }
  .modal-metric-bg { position: absolute; left: 0; top: 0; width: 0; height: 100%; border-radius: 4px; opacity: 0.15; z-index: 0; transition: width 0.6s ease-out; }
  .modal-metric-bg.slop { background: #6fd147; }
  .modal-metric-bg.diversity { background: #a855f7; }
  .modal-metric-label { position: relative; z-index: 1; text-align: left; }
  .modal-metric-value { position: relative; z-index: 1; text-align: right; font-weight: 600; font-family: var(--mono); }

  /* How it works modal styles */
  #howItWorksBody { line-height: 1.6; }
  #howItWorksBody h3 { color: var(--accent); margin-top: 20px; margin-bottom: 10px; }
  #howItWorksBody p { margin-bottom: 12px; }
  #howItWorksBody ul { margin-top: 8px; margin-bottom: 12px; padding-left: 24px; }
  #howItWorksBody a { color: var(--accent); text-decoration: none; }
  #howItWorksBody a:hover { text-decoration: underline; }

  button.secondary { background: transparent; border: 1px solid var(--accent); color: var(--accent); margin-left: 10px; }
  button.secondary:hover { background: var(--accent); color: var(--bg); }

  /* Button icon styles */
  .btn-icon { display: inline-block; width: 12px; height: 12px; margin-right: 6px; vertical-align: middle; }
  #analyzeTextBtn .btn-icon { filter: drop-shadow(0 1px 2px rgba(0,0,0,0.2)); }

  /* Mobile styles */
  @media (max-width: 768px) {
    .row { grid-template-columns: 1fr; }
    .panel { display: none; }
    .leaderboard-row.selected .leaderboard-report-btn { display: inline-block; }
  }
  @media (min-width: 769px) {
    .leaderboard-report-btn { display: none !important; }
  }

  /* Leaderboard row selection state */
  .leaderboard-row { cursor: pointer; }
  .leaderboard-row:hover { background: #1e2530; }
  .leaderboard-row.selected { background: #1a2533; border-color: var(--accent); }

  /* File upload styles */
  #fileList { display: none; min-height: 50vh; padding: 12px; background: var(--card); border: 1px solid #2a2f3a; border-radius: 8px; }
  #fileList.visible { display: block; }
  .file-item { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; margin: 6px 0; background: #10141c; border: 1px solid #2a2f3a; border-radius: 6px; }
  .file-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
  .file-size { color: var(--muted); font-size: 12px; margin-left: 12px; }
  .file-remove { background: transparent; color: #ff6b6b; border: 1px solid #ff6b6b; border-radius: 4px; padding: 4px 8px; font-size: 12px; cursor: pointer; margin-left: 12px; }
  .file-remove:hover { background: #ff6b6b; color: var(--bg); }
  textarea.drag-over { border-color: var(--accent); background: #1a1f2a; }
  .drop-hint { color: var(--muted); font-size: 13px; margin-top: 8px; }

  /* Spinner animation */
  .spinner { display: inline-block; width: 14px; height: 14px; border: 2px solid rgba(255,255,255,0.3); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; margin-left: 8px; vertical-align: middle; }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* Leaderboard header */
  .leaderboard-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
  .slop-indicator { font-size: 12px; color: var(--muted); }
  .slop-indicator.left::before { content: '← '; }
  .slop-indicator.right::after { content: ' →'; }

  /* Tooltip styles */
  .metric-with-tooltip { position: relative; cursor: help; }
  .metric-with-tooltip .tooltip-text { visibility: hidden; position: absolute; z-index: 1000; background: #2a2f3a; color: var(--fg); padding: 8px 12px; border-radius: 6px; font-size: 12px; width: 240px; left: 0; top: 100%; margin-top: 4px; opacity: 0; transition: opacity 0.2s; line-height: 1.4; box-shadow: 0 4px 6px rgba(0,0,0,0.3); pointer-events: none; }
  .metric-with-tooltip:hover .tooltip-text { visibility: visible; opacity: 1; }

  /* Help icon styles */
  .help-icon { display: inline-block; width: 16px; height: 16px; line-height: 16px; text-align: center; background: #2a2f3a; color: var(--muted); border-radius: 50%; font-size: 11px; font-weight: bold; margin-left: 6px; cursor: pointer; position: relative; }
  .help-icon:hover { background: #3a4f5a; color: var(--fg); }
  .help-text { display: none; background: #1a1f2a; border: 1px solid #2a2f3a; border-radius: 6px; padding: 10px 14px; font-size: 12px; line-height: 1.5; margin-top: 8px; margin-bottom: 8px; color: var(--muted); }
  .help-text.visible { display: block; }
  .help-text a { color: var(--accent); text-decoration: none; }
  .help-text a:hover { text-decoration: underline; }

  /* Slop/Not Slop verdict animation */
  #verdictOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; display: none; align-items: center; justify-content: center; z-index: 9999; pointer-events: none; }
  #verdictOverlay.visible { display: flex; }
  .verdict-content { text-align: center; animation: verdictFadeIn 0.9s ease-out; }
  @keyframes verdictFadeIn {
    from { opacity: 0; transform: scale(0.8); }
    to { opacity: 1; transform: scale(1); }
  }
  .verdict-text { font-size: 72px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.15em; text-shadow: 0 4px 12px rgba(0,0,0,0.5); margin: 0; font-family: "Arial", "Helvetica Neue", sans-serif; }

  

  /* Slop verdict with overlay text */
  .slop-container { position: relative; display: inline-block; }
  .verdict-text.slop { color: #ff4444; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 2; width: 100%; text-align: center; }
  /* NOT SLOP gradient segmentation */
  .verdict-text.not-slop {
    display: flex;
    align-items: center;
    gap: 8px;
    position: relative;
    animation: notSlopFadeOut 0.3s ease-out 2.6s forwards;
    padding: 20px 50px;
  }
  .verdict-text.not-slop::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #87ceeb;
    opacity: 1.0;
    border-radius: 100px;
    mask-image: radial-gradient(ellipse closest-side, black 82%, transparent 100%);
    -webkit-mask-image: radial-gradient(ellipse closest-side, black 82%, transparent 100%);
    z-index: -1;
  }
  .verdict-text.not-slop .space { flex: 0 0 20px; } /* the gap between NOT and SLOP */

  .verdict-text.not-slop .letter{
    flex: 1 1 0;           /* equal width segments */
    text-align: center;
    background-image: var(--rainbow, linear-gradient(90deg, red, blue));
    background-size: 700% 100%;                      /* 7 equal slices */
    background-position: calc(var(--i) * 100% / 6) 0;/* i in [0..6] */
    -webkit-background-clip: text;
    background-clip: text;
    -webkit-text-fill-color: transparent;
    color: transparent;
    -webkit-text-stroke: 2px white;
    paint-order: stroke fill;
  }

  /* Fade out for entire not-slop text */
  @keyframes notSlopFadeOut {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* Rainbow letter drop animation - with acceleration (ease-in) */
  .letter { display: inline-block; animation: letterDrop 0.4s ease-in; opacity: 0; animation-fill-mode: forwards; }
  @keyframes letterDrop {
    0% { transform: translateY(-150px); opacity: 0; }
    60% { transform: translateY(8px); opacity: 1; }
    80% { transform: translateY(-3px); opacity: 1; }
    100% { transform: translateY(0); opacity: 1; }
  }

  /* Sparkle animation */
  .sparkle { position: absolute; top: 5px; right: 5px; width: 35px; height: 35px; animation: sparklePopIn 0.4s ease-out 0.9s forwards; }
  @keyframes sparklePopIn {
    0% { transform: scale(0) rotate(0deg); opacity: 0; }
    50% { transform: scale(1.2) rotate(180deg); opacity: 1; }
    100% { transform: scale(1) rotate(360deg); opacity: 1; }
  }

  .paint-splash { width: 350px; height: 350px; filter: drop-shadow(0 4px 12px rgba(0,0,0,0.3)); }

  /* Light mode styles */
  body:not(.dark-mode) {
    --bg: #ffffff;
    --fg: #222;
    --muted: #666;
    --card: #f8f8f8;
    --accent: #4169e1;
  }

  body:not(.dark-mode) {
    background: #ffffff;
  }

  body:not(.dark-mode) .container {
    background: #ffffff;
  }

  body:not(.dark-mode) a {
    color: #4169e1;
  }

  body:not(.dark-mode) button {
    background: #4169e1;
    color: #fff;
  }

  body:not(.dark-mode) button.secondary {
    background: transparent;
    border: 1px solid #4169e1;
    color: #4169e1;
  }

  body:not(.dark-mode) button.secondary:hover {
    background: #4169e1;
    color: #fff;
  }

  body:not(.dark-mode) .nav-dropdown-menu {
    background: #ffffff;
    border: 1px solid #ccc;
  }

  body:not(.dark-mode) .nav-dropdown-item:hover {
    background: #e8e8e8;
  }

  body:not(.dark-mode) .leaderboard-bar {
    background: linear-gradient(90deg, #6fd147 0%, #8fe66a 100%);
  }

  body:not(.dark-mode) .leaderboard-bar.user-bar {
    background: linear-gradient(90deg, #ff9d3a 0%, #ffb66a 100%);
  }

  /* Light mode: Score bar container background */
  body:not(.dark-mode) .leaderboard-bar-container {
    background: #e8e8e8;
  }

  /* Light mode: Selected leaderboard row */
  body:not(.dark-mode) .leaderboard-row.selected {
    background: #e8f0ff;
    border-color: #4169e1;
  }

  body:not(.dark-mode) .leaderboard-row:hover {
    background: #f0f0f0;
  }

  /* Light mode: Pills (slop word hits, etc.) */
  body:not(.dark-mode) .pill {
    background: #f0f0f0;
    border: 1px solid #ccc;
    color: var(--fg);
  }

  body:not(.dark-mode) .pill b {
    color: #222;
  }

  /* Light mode: Help icon */
  body:not(.dark-mode) .help-icon {
    background: #e8e8e8;
    color: #666;
  }

  body:not(.dark-mode) .help-icon:hover {
    background: #d0d0d0;
    color: #222;
  }

  /* Light mode: Contrast match blocks */
  body:not(.dark-mode) .contrast-match {
    background: #f8f8f8;
    border: 1px solid #ddd;
    color: var(--fg);
  }

  body:not(.dark-mode) .contrast-match::before {
    color: #ccc;
  }

  /* Light mode: Help text */
  body:not(.dark-mode) .help-text {
    background: #f8f8f8;
    border: 1px solid #ddd;
    color: #666;
  }

  /* Light mode: Modal */
  body:not(.dark-mode) .modal-content {
    background: var(--card);
    border: 1px solid #ddd;
  }

  /* Light mode: Tooltips */
  body:not(.dark-mode) .metric-with-tooltip .tooltip-text {
    background: #333;
    color: #fff;
  }

  /* Light mode: Drag-over styling */
  body:not(.dark-mode) textarea.drag-over {
    border-color: #4169e1;
    background: #f0f4ff;
  }

  /* Light mode: File list and items */
  body:not(.dark-mode) #fileList {
    background: #f8f8f8;
    border: 1px solid #ddd;
  }

  body:not(.dark-mode) .file-item {
    background: #ffffff;
    border: 1px solid #ddd;
  }

  body:not(.dark-mode) .file-size {
    color: #666;
  }

  body:not(.dark-mode) .file-remove {
    background: transparent;
    color: #dc3545;
    border: 1px solid #dc3545;
  }

  body:not(.dark-mode) .file-remove:hover {
    background: #dc3545;
    color: #ffffff;
  }

  body:not(.dark-mode) .drop-hint {
    color: #666;
  }
</style>
</head>
<body>
  <div class="container">
    <div class="form-check form-switch">
      <input class="form-check-input" type="checkbox" id="darkModeToggle">
      <label class="form-check-label" for="darkModeToggle" id="toggleLabel">Light</label>
    </div>
    <div class="header">
      <a href="./"><img src="./images/eqbench_logo_sml.png" alt="EQ-bench Logo" class="logo"/></a>
      <div class="header-text">
        <h1>Slop-or-Not</h1>
      </div>
    </div>
    <p>Emotional Intelligence Benchmarks for LLMs</p>
    <p><a href="https://github.com/EQ-bench" target="_blank">Github</a> | <a href="https://arxiv.org/abs/2312.06281" target="_blank">Paper</a> | <span id="email"></span> | <a href="https://twitter.com/sam_paech" target="_blank">Twitter</a> | <a href="about.html">About</a></p>

    <p>
      <a href='index.html'>💙EQ-Bench3</a>
      <span class="nav-separator">|</span>
      <a href='spiral-bench.html'>🌀Spiral-Bench v1.2</a>
      <span class="nav-separator">|</span>
      <a href='creative_writing_longform.html'>✍️Longform Writing</a>
      <span class="nav-separator">|</span>
      <a href='creative_writing.html'>🎨Creative Writing v3</a>
      <span class="nav-separator">|</span>
      <b>☢️Slop-or-Not</b>
      <span class="nav-separator">|</span>
      <a href='judgemark-v2.html'>⚖️Judgemark v2.1</a>
      <span class="nav-separator">|</span>
      <a href='buzzbench.html'>🎤BuzzBench</a>
      <span class="nav-separator">|</span>
      <a href='diplobench.html'>🌍DiploBench</a>
      <span class="nav-separator">|</span>
      <span class="nav-dropdown">
        <button class="nav-dropdown-toggle" id="legacyDropdownToggle">
          📚Legacy Leaderboards
        </button>
        <span class="nav-dropdown-menu" id="legacyDropdownMenu">
          <a href="spiral-bench_v1.0.html" class="nav-dropdown-item">🌀Spiral-Bench v1.0</a>
          <a href="creative_writing_v2.html" class="nav-dropdown-item">🎨Creative Writing v2</a>
          <a href="eqbench-v2.html" class="nav-dropdown-item">💗EQ-Bench v2</a>
        </span>
      </span>
    </p>

  <div class="slop-content">
  <div class="section" style="display: flex; justify-content: space-between; align-items: center;">
    <div>
      <button id="analyzeTextBtn" class="secondary" style="display:none;">
        <svg class="btn-icon" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
          <circle cx="10" cy="10" r="8" fill="#39ff14"/>
        </svg>
        Analyse your text
      </button>
      <button id="viewLeaderboardBtn" class="secondary" style="display:none;">View Leaderboard</button>
      <button id="analyzeBtn" disabled style="display:none;">Analyze</button>
      <span id="status" class="muted" style="margin-left:10px;">loading resources…</span>
    </div>
    <button id="howItWorksBtn" class="secondary">How does this work?</button>
  </div>
  <div id="errors" class="section mono" style="white-space:pre-wrap;color:#ffb4b4;"></div>
  <div class="row">
    <div>
      <textarea id="input" placeholder="Add text to analyse, or drag & drop text files" style="display:none;"></textarea>
      <div id="fileList"></div>      
      <div id="leaderboard" class="visible"></div>
    </div>
    <div class="panel">
      <div id="panelContent">
        <div style="color: var(--muted); font-size: 12px; margin-bottom: 16px;">Select a model to view details</div>
      </div>
    </div>
  </div>

  <!-- Modal for detailed stats -->
  <div id="detailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 style="margin:0;">Detailed Report</h2>
        <button class="modal-close" id="closeModal">&times;</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <!-- How it works modal -->
  <div id="howItWorksModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 style="margin:0;">How does this work?</h2>
        <button class="modal-close" id="closeHowItWorksModal">&times;</button>
      </div>
      <div id="howItWorksBody">
        <h3>What is Slop-or-Not?</h3>
        <p>Slop-or-Not is a leaderboard and analysis tool for computing how much a given text looks/smells like AI "slop". It looks specifically at words and patterns that occur more frequently in AI text than in human text.</p>

        <h3>Not an AI Detector!</h3>
        <p>This tool works differently than most AI detectors: It looks for glaringly over-used patterns, rather than trying to classify the text as AI or human. It will detect words and phrases that smell of AI, but it won't reliably help you avoid AI detection. The best way to avoid AI detectors is to write in your own words.</p>

        <h3>Tips for the Analysis Tool</h3>
        <ul style="line-height: 1.8;">
          <li>Analysis works best on several pieces of writing on different topics. The more the better! It will still work on a single story or essay, but the results will be skewed by the topic.</li>
          <li>The analysis is optimised for creative writing and essays. It may work for other domains, but will likely under-report slop.</li>
        </ul>

        <h3>Slop Score Calculation</h3>
        <p>The Slop Score is a weighted composite metric designed to detect AI-generated text patterns:</p>
        <ul style="line-height: 1.8;">
          <li><strong>45%</strong> - Slop Words: Frequency of individual words that appear unnaturally often in LLM outputs</li>
          <li><strong>40%</strong> - Not-x-but-y Patterns: Frequency of contrast patterns like "not just X, but Y" which are overused by AI</li>
          <li><strong>15%</strong> - Slop Trigrams: Frequency of 3-word phrases that appear unnaturally often in LLM outputs</li>
        </ul>

        <h3>Slop Lists</h3>
        <p>The slop word and trigram lists are produced using the <a href="https://github.com/sam-paech/slop-forensics" target="_blank" style="color: var(--accent);">slop-forensics toolkit</a>. This tool identifies words and n-grams that are statistically over-represented in LLM outputs compared to human writing.</p>
        <p>The lists were computed by analyzing outputs from 10 different language models on a selection of essay and creative writing prompts, then comparing them against human-authored text.</p>
        <p>View the lists: <a href="https://github.com/sam-paech/slop-or-not/blob/main/data/slop_list.json" target="_blank" style="color: var(--accent);">Slop Words</a> | <a href="https://github.com/sam-paech/slop-or-not/blob/main/data/slop_list_trigrams.json" target="_blank" style="color: var(--accent);">Slop Trigrams</a></p>

        <h3>Over-represented Words & Trigrams</h3>
        <p>These sections show words and phrases that occur more frequently in the analyzed text than in typical human writing, based on:</p>
        <ul style="line-height: 1.8;">
          <li><strong>Words</strong>: Compared against the <a href="https://github.com/rspeer/wordfreq" target="_blank" style="color: var(--accent);">wordfreq</a> baseline (a large corpus of human language)</li>
          <li><strong>Trigrams</strong>: Compared against a human baseline corpus of essays and creative writing</li>
        </ul>

        <h3>Additional Metrics</h3>
        <p>The tool also provides various writing style metrics including lexical diversity (MATTR-500), vocabulary level (Flesch-Kincaid), sentence and paragraph length, and dialogue frequency to give a comprehensive view of the text's characteristics.</p>

        <h3>Leaderboard</h3>
        <p>The leaderboard shows how different language models score on the Slop metric, based on their outputs from a standardized set of prompts. Lower scores indicate more human-like writing patterns.</p>
      </div>
    </div>
  </div>

  <!-- Verdict overlay -->
  <div id="verdictOverlay">
    <div class="verdict-content" id="verdictContent"></div>
  </div>

<script type="module">
import { wordsOnlyLower, alphaTokens, countItems } from './js/utils.js';
import {
  loadWordfreq,
  loadHumanProfile,
  loadSlopSets,
  computeSlopIndex,
  contentTokens,
  makeNgrams,
  rankOveruseWithCounts,
  humanBigramFreq,
  humanTrigramFreq,
  lookupFrequency,
  mergePossessives
} from './js/metrics.js';
import { initPosTagger } from './js/pos-tagger.js';
import { scoreText as scoreContrast } from './js/contrast-detector.js';

const ui = {
  btn: document.getElementById('analyzeBtn'),
  status: document.getElementById('status'),
  errors: document.getElementById('errors'),
  input: document.getElementById('input'),
  fileList: document.getElementById('fileList'),
  leaderboard: document.getElementById('leaderboard'),
  viewLeaderboardBtn: document.getElementById('viewLeaderboardBtn'),
  analyzeTextBtn: document.getElementById('analyzeTextBtn'),
  panelContent: document.getElementById('panelContent'),
  modal: document.getElementById('detailModal'),
  modalBody: document.getElementById('modalBody'),
  closeModal: document.getElementById('closeModal'),
  verdictOverlay: document.getElementById('verdictOverlay'),
  verdictContent: document.getElementById('verdictContent'),
  howItWorksBtn: document.getElementById('howItWorksBtn'),
  howItWorksModal: document.getElementById('howItWorksModal'),
  closeHowItWorksModal: document.getElementById('closeHowItWorksModal'),
};

let ready = false;
let leaderboardData = null;
let normalizationRanges = null;
let userResult = null;
let selectedModel = null;
let analysisResourcesLoaded = false;
let uploadedFiles = [];

// Verdict animation
function showVerdict(slopScore) {
  const isSlop = slopScore > 25;

  const paintSplashSVG = `
    <svg class="paint-splash" viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
      <g>
        <!-- Main splash body -->
        <ellipse cx="150" cy="150" rx="90" ry="85" fill="#39ff14" opacity="0.95" transform="rotate(-12 150 150)"/>
        <ellipse cx="140" cy="160" rx="75" ry="70" fill="#39ff14" opacity="0.9" transform="rotate(25 140 160)"/>

        <!-- Irregular edges -->
        <ellipse cx="95" cy="120" rx="45" ry="35" fill="#39ff14" opacity="0.85" transform="rotate(-30 95 120)"/>
        <ellipse cx="205" cy="140" rx="50" ry="38" fill="#39ff14" opacity="0.88" transform="rotate(45 205 140)"/>
        <ellipse cx="130" cy="215" rx="40" ry="32" fill="#39ff14" opacity="0.9" transform="rotate(15 130 215)"/>
        <ellipse cx="170" cy="90" rx="35" ry="28" fill="#39ff14" opacity="0.87" transform="rotate(-50 170 90)"/>

        <!-- Drips and splatters -->
        <ellipse cx="70" cy="105" rx="25" ry="30" fill="#39ff14" opacity="0.8" transform="rotate(10 70 105)"/>
        <ellipse cx="225" cy="175" rx="28" ry="35" fill="#39ff14" opacity="0.82" transform="rotate(-20 225 175)"/>
        <ellipse cx="150" cy="235" rx="22" ry="28" fill="#39ff14" opacity="0.85" transform="rotate(5 150 235)"/>

        <!-- Small splatters -->
        <circle cx="50" cy="85" r="18" fill="#39ff14" opacity="0.75"/>
        <circle cx="240" cy="120" r="15" fill="#39ff14" opacity="0.7"/>
        <circle cx="110" cy="250" r="12" fill="#39ff14" opacity="0.78"/>
        <circle cx="195" cy="70" r="14" fill="#39ff14" opacity="0.72"/>
        <circle cx="260" cy="160" r="10" fill="#39ff14" opacity="0.68"/>
        <circle cx="40" cy="140" r="11" fill="#39ff14" opacity="0.7"/>

        <!-- Many scattered tiny dots - unevenly distributed -->
        <circle cx="30" cy="100" r="6" fill="#39ff14" opacity="0.65"/>
        <circle cx="270" cy="135" r="7" fill="#39ff14" opacity="0.63"/>
        <circle cx="180" cy="260" r="5" fill="#39ff14" opacity="0.66"/>
        <circle cx="85" cy="55" r="6" fill="#39ff14" opacity="0.64"/>
        <circle cx="245" cy="95" r="5" fill="#39ff14" opacity="0.62"/>
        <circle cx="20" cy="130" r="4" fill="#39ff14" opacity="0.6"/>
        <circle cx="285" cy="170" r="3" fill="#39ff14" opacity="0.58"/>
        <circle cx="15" cy="160" r="3" fill="#39ff14" opacity="0.55"/>
        <circle cx="65" cy="35" r="5" fill="#39ff14" opacity="0.63"/>
        <circle cx="280" cy="200" r="4" fill="#39ff14" opacity="0.6"/>
        <circle cx="220" cy="50" r="4" fill="#39ff14" opacity="0.61"/>
        <circle cx="45" cy="200" r="3" fill="#39ff14" opacity="0.57"/>
        <circle cx="265" cy="75" r="3" fill="#39ff14" opacity="0.59"/>
        <circle cx="120" cy="30" r="4" fill="#39ff14" opacity="0.62"/>
        <circle cx="190" cy="275" r="3" fill="#39ff14" opacity="0.58"/>
        <circle cx="25" cy="180" r="2" fill="#39ff14" opacity="0.54"/>
        <circle cx="290" cy="145" r="3" fill="#39ff14" opacity="0.56"/>
        <circle cx="155" cy="25" r="3" fill="#39ff14" opacity="0.6"/>
        <circle cx="10" cy="115" r="2" fill="#39ff14" opacity="0.52"/>
        <circle cx="275" cy="225" r="4" fill="#39ff14" opacity="0.61"/>
        <circle cx="35" cy="220" r="3" fill="#39ff14" opacity="0.57"/>
        <circle cx="250" cy="40" r="2" fill="#39ff14" opacity="0.55"/>
        <circle cx="95" cy="280" r="3" fill="#39ff14" opacity="0.58"/>
        <circle cx="210" cy="25" r="2" fill="#39ff14" opacity="0.53"/>
        <circle cx="8" cy="145" r="2" fill="#39ff14" opacity="0.51"/>
        <circle cx="292" cy="190" r="2" fill="#39ff14" opacity="0.54"/>
        <circle cx="140" cy="15" r="3" fill="#39ff14" opacity="0.59"/>
        <circle cx="75" cy="270" r="2" fill="#39ff14" opacity="0.56"/>
        <circle cx="230" cy="285" r="3" fill="#39ff14" opacity="0.58"/>
        <circle cx="18" cy="75" r="2" fill="#39ff14" opacity="0.53"/>
        <circle cx="285" cy="110" r="2" fill="#39ff14" opacity="0.52"/>
      </g>
    </svg>
  `;

  const sparkleSVG = `
    <svg class="sparkle" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
      <defs>
        <radialGradient id="sparkleGrad" cx="50%" cy="50%" r="50%">
          <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
          <stop offset="50%" style="stop-color:#ffd700;stop-opacity:1" />
          <stop offset="100%" style="stop-color:#ffaa00;stop-opacity:0.9" />
        </radialGradient>
        <radialGradient id="bgGlow" cx="50%" cy="50%" r="50%">
          <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.4" />
          <stop offset="70%" style="stop-color:#ffd700;stop-opacity:0.15" />
          <stop offset="100%" style="stop-color:#ffaa00;stop-opacity:0" />
        </radialGradient>
        <filter id="glow">
          <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
      <!-- Background glow circle for light mode visibility -->
      <circle cx="50" cy="50" r="48" fill="url(#bgGlow)" opacity="0.8"/>
      <!-- Main star shape with 4 points -->
      <polygon points="50,10 55,45 90,50 55,55 50,90 45,55 10,50 45,45" fill="url(#sparkleGrad)" filter="url(#glow)" stroke="#cc8800" stroke-width="1.5"/>
      <!-- Smaller diagonal star overlay -->
      <polygon points="50,25 58,48 75,50 58,52 50,75 42,52 25,50 42,48" fill="#ffffff" opacity="0.9" stroke="#dd9900" stroke-width="1"/>
      <!-- Center bright spot -->
      <circle cx="50" cy="50" r="8" fill="#ffffff" opacity="0.95" stroke="#ffcc00" stroke-width="0.5"/>
    </svg>
  `;

  let html = '';
  if (isSlop) {
    html = `
      <div class="slop-container">
        ${paintSplashSVG}
        <h1 class="verdict-text slop">Slop</h1>
      </div>
    `;
  } else {
    // Build a single rainbow and slice it into 7 equal segments by index
    const text = "NOT SLOP";
    const rainbowColors = ['#ff0080','#ff8c00','#ffd700','#00ff00','#00bfff','#8a2be2','#ff1493'];
    const colorStops = rainbowColors
      .map((c, idx) => `${c} ${(idx/(rainbowColors.length-1))*100}%`)
      .join(', ');
    const gradient = `linear-gradient(90deg, ${colorStops})`;

    let letterIndex = 0;
    const letters = text.split('').map((ch) => {
      if (ch === ' ') return '<span class="space" aria-hidden="true"></span>';
      // each letter gets equal flex width; --i controls background-position
      // use inline animation-delay so space elements do not shift nth-child timing
      const delay = (letterIndex * 0.05).toFixed(2);
      const html = `<span class="letter" style="--i:${letterIndex};--rainbow:${gradient};animation-delay:${delay}s;">${ch}</span>`;
      letterIndex++;
      return html;
    }).join('');

    html = `
      <h1 class="verdict-text not-slop">
        ${letters}
        ${sparkleSVG}
      </h1>
    `;
  }


  ui.verdictContent.innerHTML = html;
  ui.verdictOverlay.classList.add('visible');

  // Remove after animation (+0.5s more on screen: 2400ms -> 2900ms)
  setTimeout(() => {
    ui.verdictOverlay.classList.remove('visible');
  }, 2900);
}

// File management functions
function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

function renderFileList() {
  if (uploadedFiles.length === 0) {
    ui.fileList.style.display = 'none';
    ui.fileList.classList.remove('visible');
    ui.input.style.display = 'block';
    return;
  }

  ui.input.style.display = 'none';
  ui.fileList.style.display = 'block';
  ui.fileList.classList.add('visible');

  let html = '<div style="margin-bottom: 12px; color: var(--muted); font-size: 13px;">';
  html += `${uploadedFiles.length} file${uploadedFiles.length > 1 ? 's' : ''} selected for analysis:`;
  html += '</div>';

  uploadedFiles.forEach((file, index) => {
    html += `
      <div class="file-item">
        <span class="file-name" title="${file.name}">${file.name}</span>
        <span class="file-size">${formatFileSize(file.size)}</span>
        <button class="file-remove" data-index="${index}">×</button>
      </div>
    `;
  });

  ui.fileList.innerHTML = html;

  // Add event listeners to remove buttons
  ui.fileList.querySelectorAll('.file-remove').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const index = parseInt(e.target.dataset.index);
      uploadedFiles.splice(index, 1);
      renderFileList();
    });
  });
}

function handleFiles(files) {
  // Filter for text files only
  const textFiles = Array.from(files).filter(file =>
    file.type === 'text/plain' || file.name.endsWith('.txt')
  );

  if (textFiles.length === 0) {
    ui.errors.textContent = '⚠ Please drop only .txt files';
    setTimeout(() => ui.errors.textContent = '', 3000);
    return;
  }

  // Add files to the list (avoid duplicates by name)
  textFiles.forEach(file => {
    if (!uploadedFiles.some(f => f.name === file.name)) {
      uploadedFiles.push(file);
    }
  });

  renderFileList();
  ui.errors.textContent = '';
}

async function readFilesContent() {
  const contents = await Promise.all(
    uploadedFiles.map(file => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    })
  );

  return contents.join('\n\n');
}

// Additional text analytics functions
function calculateFleschKincaid(text) {
  // Split into sentences (approximate)
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
  const words = text.match(/\b\w+\b/g) || [];

  if (sentences.length === 0 || words.length === 0) return 0;

  // Count syllables (simplified algorithm)
  function countSyllables(word) {
    word = word.toLowerCase();
    if (word.length <= 3) return 1;
    word = word.replace(/(?:[^laeiouy]es|ed|[^laeiouy]e)$/, '');
    word = word.replace(/^y/, '');
    const syllables = word.match(/[aeiouy]{1,2}/g);
    return syllables ? syllables.length : 1;
  }

  const totalSyllables = words.reduce((sum, word) => sum + countSyllables(word), 0);
  const avgSyllablesPerWord = totalSyllables / words.length;
  const avgWordsPerSentence = words.length / sentences.length;

  // Flesch-Kincaid Grade Level formula
  const gradeLevel = 0.39 * avgWordsPerSentence + 11.8 * avgSyllablesPerWord - 15.59;
  return Math.max(0, gradeLevel);
}

function calculateAverageSentenceLength(text) {
  const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
  const words = text.match(/\b\w+\b/g) || [];

  if (sentences.length === 0) return 0;
  return words.length / sentences.length;
}

function calculateAverageParagraphLength(text) {
  const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 0);
  const words = text.match(/\b\w+\b/g) || [];

  if (paragraphs.length === 0) return 0;
  return words.length / paragraphs.length;
}

function calculateDialogueFrequency(text) {
  // Count quotation marks (both straight and curly)
  const quotes = (text.match(/[""\u201C\u201D]/g) || []).length;
  const chars = text.length;

  if (chars === 0) return 0;
  // Divide by 2 (pairs of quotes) and normalize to per 1000 chars
  return (quotes / 2 / chars) * 1000;
}

function renderPills(targetEl, items, fmt = (w, v) => `<b>${w}</b> <span class="muted">(${v})</span>`, showLimit = 10) {
  if (!items.length) {
    targetEl.innerHTML = '<span class="muted">None found</span>';
    return;
  }

  const visibleItems = items.slice(0, showLimit);
  const hiddenItems = items.slice(showLimit);

  let html = visibleItems.map(([w, v]) => `<span class="pill">${fmt(w, v)}</span>`).join("");

  if (hiddenItems.length > 0) {
    const toggleId = 'toggle_' + Math.random().toString(36).substr(2, 9);
    html += `<div id="${toggleId}_hidden" style="display:none;">`;
    html += hiddenItems.map(([w, v]) => `<span class="pill">${fmt(w, v)}</span>`).join("");
    html += `</div>`;
    html += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenItems.length} more</button>`;

    targetEl.innerHTML = html;

    // Add click handler
    const btn = document.getElementById(`${toggleId}_btn`);
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      btn.textContent = expanded ? 'Show less' : `Show ${hiddenItems.length} more`;
    });
  } else {
    targetEl.innerHTML = html;
  }
}

function renderContrastMatches(targetEl, matches, showLimit = 10) {
  if (!matches.length) {
    targetEl.innerHTML = '<span class="muted">None found</span>';
    return;
  }

  const visibleMatches = matches.slice(0, showLimit);
  const hiddenMatches = matches.slice(showLimit);

  let html = visibleMatches.map(m =>
    `<div class="contrast-match">${m.sentence}</div>`
  ).join("");

  if (hiddenMatches.length > 0) {
    const toggleId = 'toggle_' + Math.random().toString(36).substr(2, 9);
    html += `<div id="${toggleId}_hidden" style="display:none;">`;
    html += hiddenMatches.map(m =>
      `<div class="contrast-match">${m.sentence}</div>`
    ).join("");
    html += `</div>`;
    html += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenMatches.length} more</button>`;

    targetEl.innerHTML = html;

    const btn = document.getElementById(`${toggleId}_btn`);
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      btn.textContent = expanded ? 'Show less' : `Show ${hiddenMatches.length} more`;
    });
  } else {
    targetEl.innerHTML = html;
  }
}

// Leaderboard functions
async function loadLeaderboard() {
  const response = await fetch('data/leaderboard_results.json');
  const data = await response.json();
  leaderboardData = data.results;

  // Compute normalization ranges with 10% buffer
  const slopWordVals = leaderboardData.map(r => r.metrics.slop_list_matches_per_1k_words || 0);
  const slopTrigramVals = leaderboardData.map(r => r.metrics.slop_trigram_matches_per_1k_words || 0);
  const contrastVals = leaderboardData.map(r => r.metrics.not_x_but_y_per_1k_chars || 0);
  const vocabVals = leaderboardData.map(r => r.metrics.vocab_level || 0);
  const sentenceLengthVals = leaderboardData.map(r => r.metrics.avg_sentence_length || 0);
  const paragraphLengthVals = leaderboardData.map(r => r.metrics.avg_paragraph_length || 0);
  const dialogueVals = leaderboardData.map(r => r.metrics.dialogue_frequency || 0);
  const mattrVals = leaderboardData.map(r => r.metrics.lexical_diversity?.mattr_500 || 0);

  const computeRange = (values) => {
    const min = Math.min(...values);
    const max = Math.max(...values);
    const range = max - min;
    return {
      min: min - range * 0.1,
      max: max + range * 0.1
    };
  };

  normalizationRanges = {
    slop_words: computeRange(slopWordVals),
    slop_trigrams: computeRange(slopTrigramVals),
    contrast: computeRange(contrastVals),
    vocab_level: computeRange(vocabVals),
    avg_sentence_length: computeRange(sentenceLengthVals),
    avg_paragraph_length: computeRange(paragraphLengthVals),
    dialogue_frequency: computeRange(dialogueVals),
    mattr_500: computeRange(mattrVals)
  };

  console.log('Normalization ranges:', normalizationRanges);
}

function normalizeValue(value, range) {
  const normalized = (value - range.min) / (range.max - range.min);
  return Math.max(0, Math.min(1, normalized));
}

function computeSlopScore(slopWordScore, slopTrigramScore, contrastScore) {
  const normWords = normalizeValue(slopWordScore, normalizationRanges.slop_words);
  const normTrigrams = normalizeValue(slopTrigramScore, normalizationRanges.slop_trigrams);
  const normContrast = normalizeValue(contrastScore, normalizationRanges.contrast);

  // Weighted formula: 45% slop words + 40% not-x-but-y + 15% slop trigrams
  return (normWords * 0.45 + normContrast * 0.40 + normTrigrams * 0.15) * 100;
}

function renderLeaderboard(includeUserResult = false) {
  // Compute slop scores for all leaderboard entries
  const entries = leaderboardData.map(entry => ({
    model: entry.model,
    slopScore: computeSlopScore(
      entry.metrics.slop_list_matches_per_1k_words || 0,
      entry.metrics.slop_trigram_matches_per_1k_words || 0,
      entry.metrics.not_x_but_y_per_1k_chars || 0
    ),
    fullData: entry
  }));

  // Add user result if available
  if (includeUserResult && userResult) {
    entries.push({
      model: 'Your Text',
      slopScore: userResult.slopScore,
      fullData: userResult.fullData,
      isUser: true
    });
  }

  // Sort by slop score (higher is worse, so descending)
  entries.sort((a, b) => b.slopScore - a.slopScore);

  // Find max score for bar width calculation
  const maxScore = Math.max(...entries.map(e => e.slopScore));

  // Render
  let html = `
    <div class="leaderboard-header">
      <span class="slop-indicator left">Less slop</span>
      <span class="slop-indicator right">More slop</span>
    </div>
  `;
  entries.forEach((entry, idx) => {
    const barWidth = (entry.slopScore / maxScore) * 100;
    const rowClass = entry.isUser ? 'leaderboard-row user-result' : 'leaderboard-row';
    const barClass = entry.isUser ? 'leaderboard-bar user-bar' : 'leaderboard-bar';

    html += `
      <div class="${rowClass}">
        <div class="leaderboard-rank">${idx + 1}</div>
        <div class="leaderboard-name" title="${entry.model}">${entry.model}</div>
        <div class="leaderboard-bar-container">
          <div class="${barClass}" style="width: ${barWidth}%"></div>
        </div>
        <div class="leaderboard-score">${entry.slopScore.toFixed(1)}</div>
        <button class="leaderboard-report-btn" data-model="${entry.model}">Report</button>
      </div>
    `;
  });

  ui.leaderboard.innerHTML = html;

  // Add event listeners to rows for selection
  ui.leaderboard.querySelectorAll('.leaderboard-row').forEach(row => {
    const rowModel = row.querySelector('.leaderboard-report-btn').dataset.model;

    row.addEventListener('click', (e) => {
      // Don't trigger row click if clicking the report button
      if (e.target.classList.contains('leaderboard-report-btn')) {
        return;
      }

      // Deselect all rows
      ui.leaderboard.querySelectorAll('.leaderboard-row').forEach(r => r.classList.remove('selected'));

      // Select this row
      row.classList.add('selected');

      // Update right panel with model stats
      const entry = entries.find(e => e.model === rowModel);
      selectedModel = entry;
      updateRightPanel(entry);
    });
  });

  // Add event listeners to report buttons (for mobile)
  ui.leaderboard.querySelectorAll('.leaderboard-report-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      e.stopPropagation();
      const model = e.target.dataset.model;
      const entry = entries.find(e => e.model === model);
      showDetailModal(entry);
    });
  });

  // Auto-select the first model or user's text if available
  if (entries.length > 0) {
    const firstRow = ui.leaderboard.querySelector('.leaderboard-row');
    if (firstRow) {
      firstRow.click();
    }
  }
}

function updateRightPanel(entry) {
  const data = entry.fullData;

  let html = `<h3 style="margin: 0 0 16px;">${entry.model}</h3>`;

  if (data.metrics) {
    // Compute normalized values for bars
    const normSlopWords = normalizeValue(data.metrics.slop_list_matches_per_1k_words || 0, normalizationRanges.slop_words);
    const normSlopTrigrams = normalizeValue(data.metrics.slop_trigram_matches_per_1k_words || 0, normalizationRanges.slop_trigrams);
    const normContrast = normalizeValue(data.metrics.not_x_but_y_per_1k_chars || 0, normalizationRanges.contrast);

    html += `
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${entry.slopScore}%"></div>
        <div class="modal-metric-label">Slop Score</div>
        <div class="modal-metric-value">${entry.slopScore.toFixed(2)}</div>
        <span class="tooltip-text">Combined metric: 45% slop words + 40% not-x-but-y patterns + 15% slop trigrams, normalized across all models</span>
      </div>
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${normSlopWords * 100}%"></div>
        <div class="modal-metric-label">Slop Words (per 1k words)</div>
        <div class="modal-metric-value">${(data.metrics.slop_list_matches_per_1k_words || 0).toFixed(2)}</div>
        <span class="tooltip-text">Frequency of AI-typical single words that appear unnaturally often in LLM outputs</span>
      </div>
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${normSlopTrigrams * 100}%"></div>
        <div class="modal-metric-label">Slop Trigrams (per 1k words)</div>
        <div class="modal-metric-value">${(data.metrics.slop_trigram_matches_per_1k_words || 0).toFixed(2)}</div>
        <span class="tooltip-text">Frequency of AI-typical 3-word phrases that appear unnaturally often in LLM outputs</span>
      </div>
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${normContrast * 100}%"></div>
        <div class="modal-metric-label">Not-x-but-y Patterns (per 1k chars)</div>
        <div class="modal-metric-value">${(data.metrics.not_x_but_y_per_1k_chars || 0).toFixed(2)}</div>
        <span class="tooltip-text">Frequency of contrast patterns like "not just X, but Y" which are overused by AI</span>
      </div>
    `;

    // Writing Style Metrics
    if (data.metrics.vocab_level !== undefined ||
        data.metrics.avg_sentence_length !== undefined ||
        data.metrics.avg_paragraph_length !== undefined ||
        data.metrics.dialogue_frequency !== undefined) {
      html += `<h4 style="margin-top: 16px;">Writing Style</h4>`;

      if (data.metrics.vocab_level !== undefined) {
        const normVocab = normalizeValue(data.metrics.vocab_level, normalizationRanges.vocab_level);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normVocab * 100}%"></div>
            <div class="modal-metric-label">Vocab Level</div>
            <div class="modal-metric-value">${data.metrics.vocab_level.toFixed(2)}</div>
            <span class="tooltip-text">Flesch-Kincaid grade level - measures vocabulary complexity</span>
          </div>
        `;
      }

      if (data.metrics.avg_sentence_length !== undefined) {
        const normSentence = normalizeValue(data.metrics.avg_sentence_length, normalizationRanges.avg_sentence_length);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normSentence * 100}%"></div>
            <div class="modal-metric-label">Sentence Length</div>
            <div class="modal-metric-value">${data.metrics.avg_sentence_length.toFixed(2)}</div>
            <span class="tooltip-text">Average words per sentence - indicates pacing</span>
          </div>
        `;
      }

      if (data.metrics.avg_paragraph_length !== undefined) {
        const normParagraph = normalizeValue(data.metrics.avg_paragraph_length, normalizationRanges.avg_paragraph_length);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normParagraph * 100}%"></div>
            <div class="modal-metric-label">Paragraph Length</div>
            <div class="modal-metric-value">${data.metrics.avg_paragraph_length.toFixed(2)}</div>
            <span class="tooltip-text">Average words per paragraph - shows structural rhythm</span>
          </div>
        `;
      }

      if (data.metrics.dialogue_frequency !== undefined) {
        const normDialogue = normalizeValue(data.metrics.dialogue_frequency, normalizationRanges.dialogue_frequency);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normDialogue * 100}%"></div>
            <div class="modal-metric-label">Dialogue Frequency</div>
            <div class="modal-metric-value">${data.metrics.dialogue_frequency.toFixed(2)}</div>
            <span class="tooltip-text">Quoted dialogue per 1000 characters</span>
          </div>
        `;
      }
    }

    if (data.metrics.lexical_diversity) {
      html += `<h4 style="margin-top: 16px;">Lexical Diversity</h4>`;

      if (data.metrics.lexical_diversity.mattr_500 !== undefined) {
        const normMattr = normalizeValue(data.metrics.lexical_diversity.mattr_500, normalizationRanges.mattr_500);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normMattr * 100}%"></div>
            <div class="modal-metric-label">MATTR-500</div>
            <div class="modal-metric-value">${data.metrics.lexical_diversity.mattr_500.toFixed(4)}</div>
            <span class="tooltip-text">Moving-Average Type-Token Ratio - measures vocabulary diversity using 500-word windows</span>
          </div>
        `;
      }


      if (data.metrics.lexical_diversity.unique_words !== undefined) {
        html += `
          <div class="modal-metric">
            <div class="modal-metric-label">Unique Words</div>
            <div class="modal-metric-value">${data.metrics.lexical_diversity.unique_words.toLocaleString()}</div>
          </div>
        `;
      }

      if (data.metrics.lexical_diversity.total_words !== undefined) {
        html += `
          <div class="modal-metric">
            <div class="modal-metric-label">Total Words</div>
            <div class="modal-metric-value">${data.metrics.lexical_diversity.total_words.toLocaleString()}</div>
          </div>
        `;
      }
    }

    if (data.sample_count) {
      html += `
        <h4 style="margin-top: 16px;">Sample Info</h4>
        <div class="modal-metric">
          <div class="modal-metric-label">Sample Count</div>
          <div class="modal-metric-value">${data.sample_count}</div>
        </div>
        <div class="modal-metric">
          <div class="modal-metric-label">Total Characters</div>
          <div class="modal-metric-value">${data.total_chars.toLocaleString()}</div>
        </div>
      `;
    } else if (data.total_chars) {
      html += `
        <h4 style="margin-top: 16px;">Sample Info</h4>
        <div class="modal-metric">
          <div class="modal-metric-label">Total Characters</div>
          <div class="modal-metric-value">${data.total_chars.toLocaleString()}</div>
        </div>
      `;
    }

    // Helper function to render items with show more
    const renderItemsWithShowMore = (items, title, formatter, helpText = null) => {
      if (!items || items.length === 0) return '';

      const toggleId = 'panel_' + Math.random().toString(36).substr(2, 9);
      const helpId = 'help_' + Math.random().toString(36).substr(2, 9);

      let itemsHtml = `<h4 style="margin-top: 16px;">`;
      itemsHtml += title;

      if (helpText) {
        itemsHtml += `<span class="help-icon" id="${helpId}_btn">?</span>`;
      }

      itemsHtml += `</h4>`;

      if (helpText) {
        itemsHtml += `<div class="help-text" id="${helpId}_text">${helpText}</div>`;
      }

      itemsHtml += `<div style="margin-top: 8px;">`;

      const visibleItems = items.slice(0, 10);
      const hiddenItems = items.slice(10);

      visibleItems.forEach(item => {
        itemsHtml += formatter(item);
      });

      if (hiddenItems.length > 0) {
        itemsHtml += `<div id="${toggleId}_hidden" style="display:none;">`;
        hiddenItems.forEach(item => {
          itemsHtml += formatter(item);
        });
        itemsHtml += `</div>`;
        itemsHtml += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenItems.length} more</button>`;
      }

      itemsHtml += `</div>`;
      return itemsHtml;
    };

    // Skip over-represented and slop hits for human-baseline
    const isHumanBaseline = entry.model === 'human-baseline';

    // Add slop word hits (only for user-submitted text, not for human-baseline)
    if (data.slop_word_hits && data.slop_word_hits.length > 0 && !isHumanBaseline) {
      html += renderItemsWithShowMore(
        data.slop_word_hits,
        'Slop Word Hits',
        hit => `<span class="pill"><b>${hit[0]}</b> <span class="muted">(${hit[1]})</span></span>`,
        'Matches to a precompiled slop list produced with the <a href="https://github.com/sam-paech/slop-forensics" target="_blank" style="color: var(--accent);">slop-forensics toolkit</a>. The list identifies words that are over-represented in LLM outputs compared to human writing, computed from 10 models\' outputs on essay & creative writing prompts. <a href="https://github.com/sam-paech/slop-or-not/blob/main/data/slop_list.json" target="_blank" style="color: var(--accent);">View slop list</a>'
      );
    }

    // Add slop trigram hits (only for user-submitted text, not for human-baseline)
    if (data.slop_trigram_hits && data.slop_trigram_hits.length > 0 && !isHumanBaseline) {
      html += renderItemsWithShowMore(
        data.slop_trigram_hits,
        'Slop Trigram Hits',
        hit => `<span class="pill"><b>${hit[0]}</b> <span class="muted">(${hit[1]})</span></span>`,
        'Matches to a precompiled slop trigram list produced with the <a href="https://github.com/sam-paech/slop-forensics" target="_blank" style="color: var(--accent);">slop-forensics toolkit</a>. The list identifies 3-word phrases that are over-represented in LLM outputs compared to human writing, computed from 10 models\' outputs on essay & creative writing prompts. <a href="https://github.com/sam-paech/slop-or-not/blob/main/data/slop_list_trigrams.json" target="_blank" style="color: var(--accent);">View trigram list</a>'
      );
    }

    if (data.top_over_represented && !isHumanBaseline) {
      html += renderItemsWithShowMore(
        data.top_over_represented.words,
        'Top Over-represented Words',
        w => `<span class="pill"><b>${w.word}</b> <span class="muted">${w.ratio.toFixed(2)}×</span></span>`,
        'Words that occur more frequently in this text than in typical human-authored text (based on wordfreq baseline).'
      );

      html += renderItemsWithShowMore(
        data.top_over_represented.trigrams,
        'Top Over-represented Trigrams',
        t => `<span class="pill"><b>${t.phrase}</b> <span class="muted">${t.ratio.toFixed(2)}×</span></span>`,
        '3-word phrases that occur more frequently in this text than in typical human-authored text (based on human baseline corpus).'
      );
    }

    // Add contrast matches (always show, even for human-baseline)
    if (data.contrast_matches && data.contrast_matches.length > 0) {
      html += renderItemsWithShowMore(
        data.contrast_matches,
        'Not-x-but-y Patterns',
        m => `<div class="contrast-match">${m.sentence}</div>`
      );
    }
  }

  ui.panelContent.innerHTML = html;

  // Add click handlers for show more buttons
  ui.panelContent.querySelectorAll('.show-more').forEach(btn => {
    const toggleId = btn.id.replace('_btn', '');
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      const count = btn.textContent.match(/\d+/)[0];
      btn.textContent = expanded ? 'Show less' : `Show ${count} more`;
    });
  });

  // Add click handlers for help icons
  ui.panelContent.querySelectorAll('.help-icon').forEach(btn => {
    const helpId = btn.id.replace('_btn', '');
    const helpText = document.getElementById(`${helpId}_text`);
    if (helpText) {
      btn.addEventListener('click', () => {
        helpText.classList.toggle('visible');
      });
    }
  });
}

function showDetailModal(entry) {
  const data = entry.fullData;

  let html = `<h3>${entry.model}</h3>`;

  if (data.metrics) {
    // Compute normalized values for bars
    const normSlopWords = normalizeValue(data.metrics.slop_list_matches_per_1k_words || 0, normalizationRanges.slop_words);
    const normSlopTrigrams = normalizeValue(data.metrics.slop_trigram_matches_per_1k_words || 0, normalizationRanges.slop_trigrams);
    const normContrast = normalizeValue(data.metrics.not_x_but_y_per_1k_chars || 0, normalizationRanges.contrast);

    html += `
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${entry.slopScore}%"></div>
        <div class="modal-metric-label">Slop Score</div>
        <div class="modal-metric-value">${entry.slopScore.toFixed(2)}</div>
        <span class="tooltip-text">Combined metric: 45% slop words + 40% not-x-but-y patterns + 15% slop trigrams, normalized across all models</span>
      </div>
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${normSlopWords * 100}%"></div>
        <div class="modal-metric-label">Slop Words (per 1k words)</div>
        <div class="modal-metric-value">${(data.metrics.slop_list_matches_per_1k_words || 0).toFixed(2)}</div>
        <span class="tooltip-text">Frequency of AI-typical single words that appear unnaturally often in LLM outputs</span>
      </div>
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${normSlopTrigrams * 100}%"></div>
        <div class="modal-metric-label">Slop Trigrams (per 1k words)</div>
        <div class="modal-metric-value">${(data.metrics.slop_trigram_matches_per_1k_words || 0).toFixed(2)}</div>
        <span class="tooltip-text">Frequency of AI-typical 3-word phrases that appear unnaturally often in LLM outputs</span>
      </div>
      <div class="modal-metric metric-with-tooltip">
        <div class="modal-metric-bg slop" style="width: ${normContrast * 100}%"></div>
        <div class="modal-metric-label">Not-x-but-y Patterns (per 1k chars)</div>
        <div class="modal-metric-value">${(data.metrics.not_x_but_y_per_1k_chars || 0).toFixed(2)}</div>
        <span class="tooltip-text">Frequency of contrast patterns like "not just X, but Y" which are overused by AI</span>
      </div>
    `;

    // Writing Style Metrics
    if (data.metrics.vocab_level !== undefined ||
        data.metrics.avg_sentence_length !== undefined ||
        data.metrics.avg_paragraph_length !== undefined ||
        data.metrics.dialogue_frequency !== undefined) {
      html += `<h4 style="margin-top: 16px;">Writing Style</h4>`;

      if (data.metrics.vocab_level !== undefined) {
        const normVocab = normalizeValue(data.metrics.vocab_level, normalizationRanges.vocab_level);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normVocab * 100}%"></div>
            <div class="modal-metric-label">Vocab Level</div>
            <div class="modal-metric-value">${data.metrics.vocab_level.toFixed(2)}</div>
            <span class="tooltip-text">Flesch-Kincaid grade level - measures vocabulary complexity</span>
          </div>
        `;
      }

      if (data.metrics.avg_sentence_length !== undefined) {
        const normSentence = normalizeValue(data.metrics.avg_sentence_length, normalizationRanges.avg_sentence_length);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normSentence * 100}%"></div>
            <div class="modal-metric-label">Sentence Length</div>
            <div class="modal-metric-value">${data.metrics.avg_sentence_length.toFixed(2)}</div>
            <span class="tooltip-text">Average words per sentence - indicates pacing</span>
          </div>
        `;
      }

      if (data.metrics.avg_paragraph_length !== undefined) {
        const normParagraph = normalizeValue(data.metrics.avg_paragraph_length, normalizationRanges.avg_paragraph_length);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normParagraph * 100}%"></div>
            <div class="modal-metric-label">Paragraph Length</div>
            <div class="modal-metric-value">${data.metrics.avg_paragraph_length.toFixed(2)}</div>
            <span class="tooltip-text">Average words per paragraph - shows structural rhythm</span>
          </div>
        `;
      }

      if (data.metrics.dialogue_frequency !== undefined) {
        const normDialogue = normalizeValue(data.metrics.dialogue_frequency, normalizationRanges.dialogue_frequency);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normDialogue * 100}%"></div>
            <div class="modal-metric-label">Dialogue Frequency</div>
            <div class="modal-metric-value">${data.metrics.dialogue_frequency.toFixed(2)}</div>
            <span class="tooltip-text">Quoted dialogue per 1000 characters</span>
          </div>
        `;
      }
    }

    if (data.metrics.lexical_diversity) {
      html += `<h4 style="margin-top: 16px;">Lexical Diversity</h4>`;

      if (data.metrics.lexical_diversity.mattr_500 !== undefined) {
        const normMattr = normalizeValue(data.metrics.lexical_diversity.mattr_500, normalizationRanges.mattr_500);
        html += `
          <div class="modal-metric metric-with-tooltip">
            <div class="modal-metric-bg diversity" style="width: ${normMattr * 100}%"></div>
            <div class="modal-metric-label">MATTR-500</div>
            <div class="modal-metric-value">${data.metrics.lexical_diversity.mattr_500.toFixed(4)}</div>
            <span class="tooltip-text">Moving-Average Type-Token Ratio - measures vocabulary diversity using 500-word windows</span>
          </div>
        `;
      }


      if (data.metrics.lexical_diversity.unique_words !== undefined) {
        html += `
          <div class="modal-metric">
            <div class="modal-metric-label">Unique Words</div>
            <div class="modal-metric-value">${data.metrics.lexical_diversity.unique_words.toLocaleString()}</div>
          </div>
        `;
      }

      if (data.metrics.lexical_diversity.total_words !== undefined) {
        html += `
          <div class="modal-metric">
            <div class="modal-metric-label">Total Words</div>
            <div class="modal-metric-value">${data.metrics.lexical_diversity.total_words.toLocaleString()}</div>
          </div>
        `;
      }
    }

    if (data.sample_count) {
      html += `
        <h4 style="margin-top: 16px;">Sample Info</h4>
        <div class="modal-metric">
          <div class="modal-metric-label">Sample Count</div>
          <div class="modal-metric-value">${data.sample_count}</div>
        </div>
        <div class="modal-metric">
          <div class="modal-metric-label">Total Characters</div>
          <div class="modal-metric-value">${data.total_chars.toLocaleString()}</div>
        </div>
      `;
    }

    // Helper function to render items with show more
    const renderItemsWithShowMore = (items, title, formatter, helpText = null) => {
      if (!items || items.length === 0) return '';

      const toggleId = 'modal_' + Math.random().toString(36).substr(2, 9);
      const helpId = 'help_' + Math.random().toString(36).substr(2, 9);

      let itemsHtml = `<h4 style="margin-top: 16px;">`;
      itemsHtml += title;

      if (helpText) {
        itemsHtml += `<span class="help-icon" id="${helpId}_btn">?</span>`;
      }

      itemsHtml += `</h4>`;

      if (helpText) {
        itemsHtml += `<div class="help-text" id="${helpId}_text">${helpText}</div>`;
      }

      itemsHtml += `<div style="margin-top: 8px;">`;

      const visibleItems = items.slice(0, 10);
      const hiddenItems = items.slice(10);

      visibleItems.forEach(item => {
        itemsHtml += formatter(item);
      });

      if (hiddenItems.length > 0) {
        itemsHtml += `<div id="${toggleId}_hidden" style="display:none;">`;
        hiddenItems.forEach(item => {
          itemsHtml += formatter(item);
        });
        itemsHtml += `</div>`;
        itemsHtml += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenItems.length} more</button>`;
      }

      itemsHtml += `</div>`;
      return itemsHtml;
    };

    // Skip over-represented and slop hits for human-baseline
    const isHumanBaseline = entry.model === 'human-baseline';

    // Add slop word hits (only for user-submitted text, not for human-baseline)
    if (data.slop_word_hits && data.slop_word_hits.length > 0 && !isHumanBaseline) {
      html += renderItemsWithShowMore(
        data.slop_word_hits,
        'Slop Word Hits',
        hit => `<span class="pill"><b>${hit[0]}</b> <span class="muted">(${hit[1]})</span></span>`,
        'Matches to a precompiled slop list produced with the <a href="https://github.com/sam-paech/slop-forensics" target="_blank" style="color: var(--accent);">slop-forensics toolkit</a>. The list identifies words that are over-represented in LLM outputs compared to human writing, computed from 10 models\' outputs on essay & creative writing prompts. <a href="https://github.com/sam-paech/slop-or-not/blob/main/data/slop_list.json" target="_blank" style="color: var(--accent);">View slop list</a>'
      );
    }

    // Add slop trigram hits (only for user-submitted text, not for human-baseline)
    if (data.slop_trigram_hits && data.slop_trigram_hits.length > 0 && !isHumanBaseline) {
      html += renderItemsWithShowMore(
        data.slop_trigram_hits,
        'Slop Trigram Hits',
        hit => `<span class="pill"><b>${hit[0]}</b> <span class="muted">(${hit[1]})</span></span>`,
        'Matches to a precompiled slop trigram list produced with the <a href="https://github.com/sam-paech/slop-forensics" target="_blank" style="color: var(--accent);">slop-forensics toolkit</a>. The list identifies 3-word phrases that are over-represented in LLM outputs compared to human writing, computed from 10 models\' outputs on essay & creative writing prompts. <a href="https://github.com/sam-paech/slop-or-not/blob/main/data/slop_list_trigrams.json" target="_blank" style="color: var(--accent);">View trigram list</a>'
      );
    }

    if (data.top_over_represented && !isHumanBaseline) {
      html += renderItemsWithShowMore(
        data.top_over_represented.words,
        'Top Over-represented Words',
        w => `<span class="pill"><b>${w.word}</b> <span class="muted">${w.ratio.toFixed(2)}×</span></span>`,
        'Words that occur more frequently in this text than in typical human-authored text (based on wordfreq baseline).'
      );

      html += renderItemsWithShowMore(
        data.top_over_represented.trigrams,
        'Top Over-represented Trigrams',
        t => `<span class="pill"><b>${t.phrase}</b> <span class="muted">${t.ratio.toFixed(2)}×</span></span>`,
        '3-word phrases that occur more frequently in this text than in typical human-authored text (based on human baseline corpus).'
      );
    }

    // Add contrast matches (always show, even for human-baseline)
    if (data.contrast_matches && data.contrast_matches.length > 0) {
      html += renderItemsWithShowMore(
        data.contrast_matches,
        'Not-x-but-y Patterns',
        m => `<div class="contrast-match">${m.sentence}</div>`
      );
    }
  }

  ui.modalBody.innerHTML = html;

  // Add click handlers for show more buttons
  ui.modalBody.querySelectorAll('.show-more').forEach(btn => {
    const toggleId = btn.id.replace('_btn', '');
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      const count = btn.textContent.match(/\d+/)[0];
      btn.textContent = expanded ? 'Show less' : `Show ${count} more`;
    });
  });

  // Add click handlers for help icons
  ui.modalBody.querySelectorAll('.help-icon').forEach(btn => {
    const helpId = btn.id.replace('_btn', '');
    const helpText = document.getElementById(`${helpId}_text`);
    if (helpText) {
      btn.addEventListener('click', () => {
        helpText.classList.toggle('visible');
      });
    }
  });

  ui.modal.classList.add('visible');
}

function hideLeaderboard() {
  ui.leaderboard.classList.remove('visible');
  ui.leaderboard.style.display = 'none';

  // Show either file list or input box
  if (uploadedFiles.length > 0) {
    renderFileList();
  } else {
    ui.input.style.display = 'block';
  }

  ui.viewLeaderboardBtn.style.display = 'inline-block';
  ui.analyzeTextBtn.style.display = 'none';
  ui.btn.style.display = 'inline-block';
  ui.status.style.display = 'inline';
}

function showLeaderboard() {
  ui.input.style.display = 'none';
  ui.fileList.style.display = 'none';
  ui.fileList.classList.remove('visible');
  ui.leaderboard.style.display = 'block';
  ui.leaderboard.classList.add('visible');
  ui.viewLeaderboardBtn.style.display = 'none';
  ui.analyzeTextBtn.style.display = 'inline-block';
  ui.btn.style.display = 'none';
  ui.status.style.display = 'none';
  renderLeaderboard(userResult !== null);
}

async function loadAnalysisResources() {
  if (analysisResourcesLoaded) {
    return true; // Already loaded
  }

  let posLoaded = false;

  try {
    // Try to load POS tagger (optional for Stage2 patterns)
    ui.status.textContent = "loading POS tagger…";
    try {
      await initPosTagger();
      posLoaded = true;
      console.log('✓ POS tagger loaded - Stage2 patterns enabled');
    } catch (posError) {
      console.warn('POS tagger failed to load:', posError.message);
      console.warn('⚠ Stage2 contrast patterns will be disabled. Stage1 patterns will still work.');
      // Continue without POS tagger
    }

    ui.status.textContent = "loading wordfreq…";
    await loadWordfreq();

    ui.status.textContent = "loading analysis resources…";
    await Promise.all([loadHumanProfile(), loadSlopSets()]);

    analysisResourcesLoaded = true;
    ui.status.textContent = "ready";

    if (!posLoaded) {
      ui.errors.textContent = "⚠ Note: POS tagger could not be loaded. Stage2 contrast patterns are disabled, but Stage1 patterns will still work.";
    }

    ui.btn.disabled = false;
    return true;
  } catch (e) {
    ui.status.textContent = "ERROR";
    const errorMsg = String(e?.message || e);
    ui.errors.textContent = `❌ ${errorMsg}\n\nFailed to load analysis resources. Please check:\n1. Your internet connection\n2. Browser console for details\n3. Whether CDN services are accessible`;
    console.error('Analysis resources loading failed:', e);
    ui.btn.disabled = true;
    return false;
  }
}

async function init() {
  try {
    ui.status.textContent = "loading leaderboard…";
    await loadLeaderboard();

    ready = true;
    ui.status.textContent = "";

    // Show leaderboard by default on page load
    showLeaderboard();
  } catch (e) {
    ui.status.textContent = "ERROR";
    const errorMsg = String(e?.message || e);
    ui.errors.textContent = `❌ ${errorMsg}\n\nFailed to load leaderboard. Please check:\n1. Your internet connection\n2. Browser console for details\n3. Whether the data file exists`;
    console.error('Initialization failed:', e);
  }
}

ui.btn.addEventListener('click', async () => {
  if (!ready) return;
  ui.errors.textContent = "";

  // Disable button and show spinner
  ui.btn.disabled = true;
  const originalBtnText = ui.btn.textContent;
  ui.btn.innerHTML = 'Analyzing<span class="spinner"></span>';

  try {
    // Determine whether to use files or text input
    let raw = "";
    if (uploadedFiles.length > 0) {
      try {
        raw = await readFilesContent();
      } catch (err) {
        ui.errors.textContent = `❌ Error reading files: ${err.message}`;
        ui.btn.disabled = false;
        ui.btn.textContent = originalBtnText;
        return;
      }
    } else {
      raw = ui.input.value || "";
    }

    if (!raw || raw.trim().length === 0) {
      ui.errors.textContent = uploadedFiles.length > 0
        ? "⚠ The selected files appear to be empty"
        : "⚠ Please enter some text to analyze";
      ui.btn.disabled = false;
      ui.btn.textContent = originalBtnText;
      return;
    }

    const chars = raw.length;
    const toks0 = wordsOnlyLower(raw);
    const toks = alphaTokens(toks0);
    const nWords = toks.length;

    // Slop - now returns separate scores and hit tracking
    const slopResult = computeSlopIndex(toks, true);  // trackHits = true

    // Repetition score
    const toksContent = contentTokens(toks);
    const bigs = makeNgrams(toksContent, 2);
    const tris = makeNgrams(toksContent, 3);

    const topBCounts = rankOveruseWithCounts(bigs, humanBigramFreq, 40);
    const topTCounts = rankOveruseWithCounts(tris, humanTrigramFreq, 40);

    const top_bigram_count = topBCounts.reduce((s, r) => s + r[2], 0);
    const top_trigram_count = topTCounts.reduce((s, r) => s + r[2], 0);
    const content_word_count = toksContent.length;

    const repetition_score =
      content_word_count > 0
        ? ((top_bigram_count + top_trigram_count) / content_word_count) * 1000
        : 0;

    // Contrast patterns
    const contrastResult = scoreContrast(raw);

    // Calculate lexical diversity (MATTR-500)
    const windowSize = 500;
    const uniqueWords = new Set(toks);
    const simpleTTR = uniqueWords.size / nWords;

    let mattr = 0;
    if (nWords >= windowSize) {
      let sumTTR = 0;
      let windowCount = 0;

      for (let i = 0; i <= nWords - windowSize; i++) {
        const windowTokens = toks.slice(i, i + windowSize);
        const windowUnique = new Set(windowTokens);
        const windowTTR = windowUnique.size / windowSize;
        sumTTR += windowTTR;
        windowCount++;
      }

      mattr = sumTTR / windowCount;
    } else {
      mattr = simpleTTR;
    }

    // Calculate additional writing metrics
    const vocabLevel = calculateFleschKincaid(raw);
    const avgSentenceLength = calculateAverageSentenceLength(raw);
    const avgParagraphLength = calculateAverageParagraphLength(raw);
    const dialogueFrequency = calculateDialogueFrequency(raw);

    // Compute slop score for user text using new 3-component formula
    const userSlopScore = computeSlopScore(
      slopResult.wordScore,
      slopResult.trigramScore,
      contrastResult.rate_per_1k
    );

    // Store user result
    userResult = {
      slopScore: userSlopScore,
      fullData: {
        total_chars: chars,
        metrics: {
          slop_list_matches_per_1k_words: slopResult.wordScore,
          slop_trigram_matches_per_1k_words: slopResult.trigramScore,
          ngram_repetition_score: repetition_score,
          not_x_but_y_per_1k_chars: contrastResult.rate_per_1k,
          lexical_diversity: {
            mattr_500: mattr,
            type_token_ratio: simpleTTR,
            unique_words: uniqueWords.size,
            total_words: nWords
          },
          vocab_level: vocabLevel,
          avg_sentence_length: avgSentenceLength,
          avg_paragraph_length: avgParagraphLength,
          dialogue_frequency: dialogueFrequency
        },
        slop_word_hits: slopResult.wordHits,
        slop_trigram_hits: slopResult.trigramHits,
        contrast_matches: contrastResult.matches.slice(0, 100).map(m => ({
          pattern_name: m.pattern_name,
          sentence: m.sentence,
          match_text: m.match_text || '',
          sentence_count: m.sentence_count || 1
        }))
      }
    };

  // Top over-represented words (vs wordfreq baseline)
  // Merge possessives for word counts (but not for ngrams)
  let wordCounts = countItems(toksContent);
  wordCounts = mergePossessives(wordCounts);
  
  const totalWords = Array.from(wordCounts.values()).reduce((a, b) => a + b, 0);
  const wordOverrep = [];
  
  for (const [w, cnt] of wordCounts.entries()) {
    const baselineFreq = lookupFrequency(w); // proportion (0-1)
    if (!baselineFreq) continue;
    
    const modelFreq = cnt / totalWords; // proportion (0-1)
    const ratio = modelFreq / baselineFreq;
    
    // Only show words that are significantly over-represented
    if (ratio > 1.5 && cnt >= 2) {
      wordOverrep.push([w, ratio, cnt]);
    }
  }
  wordOverrep.sort((a, b) => b[1] - a[1]);
  const topWords = wordOverrep.slice(0, 100);

  // Update user result with top_over_represented data
  userResult.fullData.top_over_represented = {
    words: topWords.map(([w, ratio, cnt]) => ({ word: w, ratio, count: cnt })),
    bigrams: topBCounts.slice(0, 100).map(([phrase, ratio, count]) => ({ phrase, ratio, count })),
    trigrams: topTCounts.slice(0, 100).map(([phrase, ratio, count]) => ({ phrase, ratio, count }))
  };

  // Show verdict animation
  showVerdict(userSlopScore);

  // Re-enable button
  ui.btn.disabled = false;
  ui.btn.textContent = originalBtnText;

  // Clear uploaded files and input text after successful analysis
  uploadedFiles = [];
  ui.input.value = '';

  // Show leaderboard immediately (don't wait for animation)
  showLeaderboard();

  // Select user's result immediately
  setTimeout(() => {
    const userRow = ui.leaderboard.querySelector('.leaderboard-row.user-result');
    if (userRow) {
      // Click the row to select it immediately
      userRow.click();
    }
  }, 100);

  // Scroll to user's position on leaderboard after animation completes
  setTimeout(() => {
    const userRow = ui.leaderboard.querySelector('.leaderboard-row.user-result');
    if (userRow) {
      userRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }, 3000);

  } catch (error) {
    console.error('Analysis error:', error);
    ui.errors.textContent = `❌ Analysis failed: ${error.message}`;
    ui.btn.disabled = false;
    ui.btn.textContent = originalBtnText;
  }
});

// Button event listeners
ui.viewLeaderboardBtn.addEventListener('click', () => {
  showLeaderboard();
});

ui.analyzeTextBtn.addEventListener('click', async () => {
  hideLeaderboard();

  // Load analysis resources if not already loaded
  if (!analysisResourcesLoaded) {
    ui.status.style.display = 'inline';
    const success = await loadAnalysisResources();
    if (!success) {
      // If loading failed, go back to leaderboard
      showLeaderboard();
      return;
    }
  } else {
    ui.status.textContent = "ready";
  }
});

ui.closeModal.addEventListener('click', () => {
  ui.modal.classList.remove('visible');
});

ui.modal.addEventListener('click', (e) => {
  if (e.target === ui.modal) {
    ui.modal.classList.remove('visible');
  }
});

// How it works modal handlers
ui.howItWorksBtn.addEventListener('click', () => {
  ui.howItWorksModal.classList.add('visible');
});

ui.closeHowItWorksModal.addEventListener('click', () => {
  ui.howItWorksModal.classList.remove('visible');
});

ui.howItWorksModal.addEventListener('click', (e) => {
  if (e.target === ui.howItWorksModal) {
    ui.howItWorksModal.classList.remove('visible');
  }
});

// Drag and drop event handlers
ui.input.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
  ui.input.classList.add('drag-over');
});

ui.input.addEventListener('dragleave', (e) => {
  e.preventDefault();
  e.stopPropagation();
  ui.input.classList.remove('drag-over');
});

ui.input.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();
  ui.input.classList.remove('drag-over');

  const files = e.dataTransfer.files;
  if (files.length > 0) {
    handleFiles(files);
  }
});

// Also handle file selection on the file list area
ui.fileList.addEventListener('dragover', (e) => {
  e.preventDefault();
  e.stopPropagation();
});

ui.fileList.addEventListener('drop', (e) => {
  e.preventDefault();
  e.stopPropagation();

  const files = e.dataTransfer.files;
  if (files.length > 0) {
    handleFiles(files);
  }
});

init();
</script>

<script src="js/eqbench-utils.js"></script>
<script>
// Initialize EQBench utilities
document.addEventListener('DOMContentLoaded', function() {
  displayEncodedEmail();
  applySystemTheme();
  setupDarkModeToggle();

  // Wire up "Learn more" link to "How it works" modal
  const learnMoreLink = document.getElementById('learnMoreLink');
  const howItWorksBtn = document.getElementById('howItWorksBtn');
  if (learnMoreLink && howItWorksBtn) {
    learnMoreLink.addEventListener('click', function(e) {
      e.preventDefault();
      howItWorksBtn.click();
    });
  }
});
</script>

</div><!-- .slop-content -->
</div><!-- .container -->
</body>
</html>
