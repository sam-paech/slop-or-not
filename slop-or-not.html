<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Writing Metrics: Slop • Repetition • Contrast • Top n-grams</title>
<style>
  :root { --bg:#0f1115; --fg:#e6e6e6; --muted:#9aa4ad; --card:#171a21; --accent:#6aa0ff; }
  * { box-sizing: border-box; }
  body { margin: 0; padding: 24px; background: var(--bg); color: var(--fg); font: 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
  h1 { font-size: 18px; margin: 0 0 12px; }
  .row { display: grid; grid-template-columns: 1fr 380px; gap: 18px; }
  textarea { width: 100%; height: 50vh; padding: 12px; background: var(--card); color: var(--fg); border: 1px solid #2a2f3a; border-radius: 8px; resize: vertical; }
  button { background: var(--accent); color: #0b0f16; border: 0; border-radius: 8px; padding: 10px 14px; font-weight: 600; cursor: pointer; }
  button:disabled { opacity: .55; cursor: not-allowed; }
  button.show-more { background: transparent; color: var(--accent); padding: 6px 10px; font-size: 12px; margin-top: 6px; border: 1px solid var(--accent); }
  button.show-more:hover { background: var(--accent); color: var(--bg); }
  .panel { background: var(--card); border: 1px solid #2a2f3a; border-radius: 8px; padding: 12px 14px; }
  .muted { color: var(--muted); }
  .metric { display: grid; grid-template-columns: 1fr auto; gap: 8px; padding: 6px 0; border-bottom: 1px dashed #2a2f3a; }
  .metric:last-child { border-bottom: 0; }
  .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
  .section { margin-top: 16px; }
  .pill { display: inline-block; background: #10141c; border: 1px solid #2a2f3a; border-radius: 999px; padding: 4px 8px; margin: 4px 6px 0 0; font-size: 12px; }
  .pill b { color: #b8c7ff; }
  .contrast-match { background: #1a1f2a; border: 1px solid #3a4f5a; border-radius: 6px; padding: 8px 10px; margin: 6px 0; font-size: 12px; }
  .contrast-match .pattern { color: #8a9aaa; font-size: 10px; margin-bottom: 4px; }
  details { margin-top: 10px; }
  summary { cursor: pointer; color: #c7d5ff; }
  code { background: #10141c; padding: 2px 6px; border-radius: 6px; }
</style>
</head>
<body>
  <h1>Writing Metrics</h1>
  <div class="row">
    <div>
      <textarea id="input" placeholder="Paste or type your long-form text here…"></textarea>
      <div class="section">
        <button id="analyzeBtn" disabled>Analyze</button>
        <span id="status" class="muted" style="margin-left:10px;">loading resources…</span>
      </div>
      <div id="errors" class="section mono" style="white-space:pre-wrap;color:#ffb4b4;"></div>
    </div>
    <div class="panel">
      <div class="metric"><div>Total characters</div><div id="m_chars" class="mono">—</div></div>
      <div class="metric"><div>Total words</div><div id="m_words" class="mono">—</div></div>
      <div class="metric"><div>Slop index (per 1k words)</div><div id="m_slop" class="mono">—</div></div>
      <div class="metric"><div>Repetition score (%)</div><div id="m_rep" class="mono">—</div></div>
      <div class="metric"><div>Contrast patterns (per 1k chars)</div><div id="m_contrast" class="mono">—</div></div>

      <div class="section">
        <details open>
          <summary>Top over-represented words</summary>
          <div id="topWords" style="margin-top:8px;"></div>
        </details>
        <details open>
          <summary>Top bigrams (over-use vs human)</summary>
          <div id="topBigrams" style="margin-top:8px;"></div>
        </details>
        <details open>
          <summary>Top trigrams (over-use vs human)</summary>
          <div id="topTrigrams" style="margin-top:8px;"></div>
        </details>
        <details>
          <summary>Contrast patterns ("not X, but Y")</summary>
          <div id="contrastMatches" style="margin-top:8px;"></div>
        </details>
        <details>
          <summary>Exact repeated phrases (trigram-based)</summary>
          <div id="topPhrases" style="margin-top:8px;"></div>
        </details>
      </div>
      <div class="section muted" style="font-size:12px;">
        Resources in <code>data/</code>: <code>human_writing_profile.json</code>, <code>slop_list.json</code>, <code>slop_list_bigrams.json</code>, <code>slop_list_trigrams.json</code>.
      </div>
    </div>
  </div>

<script type="module">
import { wordsOnlyLower, alphaTokens, countItems } from './js/utils.js';
import {
  loadSUBTLEX,
  loadHumanProfile,
  loadSlopSets,
  computeSlopIndex,
  contentTokens,
  makeNgrams,
  rankOveruseWithCounts,
  extractRepeatedPhrases,
  lookupZipf,
  humanBigramFreq,
  humanTrigramFreq
} from './js/metrics.js';
import { initPosTagger } from './js/pos-tagger.js';
import { scoreText as scoreContrast } from './js/contrast-detector.js';

const ui = {
  btn: document.getElementById('analyzeBtn'),
  status: document.getElementById('status'),
  errors: document.getElementById('errors'),
  input: document.getElementById('input'),
  m_chars: document.getElementById('m_chars'),
  m_words: document.getElementById('m_words'),
  m_slop: document.getElementById('m_slop'),
  m_rep: document.getElementById('m_rep'),
  m_contrast: document.getElementById('m_contrast'),
  topWords: document.getElementById('topWords'),
  topBigrams: document.getElementById('topBigrams'),
  topTrigrams: document.getElementById('topTrigrams'),
  contrastMatches: document.getElementById('contrastMatches'),
  topPhrases: document.getElementById('topPhrases'),
};

let ready = false;

function renderPills(targetEl, items, fmt = (w, v) => `<b>${w}</b> <span class="muted">(${v})</span>`, showLimit = 10) {
  if (!items.length) {
    targetEl.innerHTML = '<span class="muted">None found</span>';
    return;
  }

  const visibleItems = items.slice(0, showLimit);
  const hiddenItems = items.slice(showLimit);

  let html = visibleItems.map(([w, v]) => `<span class="pill">${fmt(w, v)}</span>`).join("");

  if (hiddenItems.length > 0) {
    const toggleId = 'toggle_' + Math.random().toString(36).substr(2, 9);
    html += `<div id="${toggleId}_hidden" style="display:none;">`;
    html += hiddenItems.map(([w, v]) => `<span class="pill">${fmt(w, v)}</span>`).join("");
    html += `</div>`;
    html += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenItems.length} more</button>`;

    targetEl.innerHTML = html;

    // Add click handler
    const btn = document.getElementById(`${toggleId}_btn`);
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      btn.textContent = expanded ? 'Show less' : `Show ${hiddenItems.length} more`;
    });
  } else {
    targetEl.innerHTML = html;
  }
}

function renderContrastMatches(targetEl, matches, showLimit = 10) {
  if (!matches.length) {
    targetEl.innerHTML = '<span class="muted">None found</span>';
    return;
  }

  const visibleMatches = matches.slice(0, showLimit);
  const hiddenMatches = matches.slice(showLimit);

  let html = visibleMatches.map(m =>
    `<div class="contrast-match">
      <div class="pattern">${m.pattern_name}</div>
      <div>${m.sentence}</div>
    </div>`
  ).join("");

  if (hiddenMatches.length > 0) {
    const toggleId = 'toggle_' + Math.random().toString(36).substr(2, 9);
    html += `<div id="${toggleId}_hidden" style="display:none;">`;
    html += hiddenMatches.map(m =>
      `<div class="contrast-match">
        <div class="pattern">${m.pattern_name}</div>
        <div>${m.sentence}</div>
      </div>`
    ).join("");
    html += `</div>`;
    html += `<button class="show-more" id="${toggleId}_btn">Show ${hiddenMatches.length} more</button>`;

    targetEl.innerHTML = html;

    const btn = document.getElementById(`${toggleId}_btn`);
    const hiddenDiv = document.getElementById(`${toggleId}_hidden`);
    let expanded = false;

    btn.addEventListener('click', () => {
      expanded = !expanded;
      hiddenDiv.style.display = expanded ? 'block' : 'none';
      btn.textContent = expanded ? 'Show less' : `Show ${hiddenMatches.length} more`;
    });
  } else {
    targetEl.innerHTML = html;
  }
}

async function init() {
  let posLoaded = false;

  try {
    // Try to load POS tagger (optional for Stage2 patterns)
    ui.status.textContent = "loading POS tagger…";
    try {
      await initPosTagger();
      posLoaded = true;
      console.log('✓ POS tagger loaded - Stage2 patterns enabled');
    } catch (posError) {
      console.warn('POS tagger failed to load:', posError.message);
      console.warn('⚠ Stage2 contrast patterns will be disabled. Stage1 patterns will still work.');
      // Continue without POS tagger
    }

    ui.status.textContent = "loading SUBTLEX…";
    await loadSUBTLEX();

    ui.status.textContent = "loading resources…";
    await Promise.all([loadHumanProfile(), loadSlopSets()]);

    ready = true;
    const statusMsg = posLoaded
      ? "ready (Stage1 + Stage2 patterns)"
      : "ready (Stage1 patterns only - POS tagger unavailable)";
    ui.status.textContent = statusMsg;

    if (!posLoaded) {
      ui.errors.textContent = "⚠ Note: POS tagger could not be loaded. Stage2 contrast patterns are disabled, but Stage1 patterns will still work.";
    }

    ui.btn.disabled = false;
  } catch (e) {
    ui.status.textContent = "CRITICAL ERROR";
    const errorMsg = String(e?.message || e);
    ui.errors.textContent = `❌ ${errorMsg}\n\nThe application cannot function without this component. Please check:\n1. Your internet connection\n2. Browser console for details\n3. Whether CDN services are accessible`;
    console.error('Initialization failed:', e);
    // Keep button disabled on critical errors
    ui.btn.disabled = true;
  }
}

ui.btn.addEventListener('click', () => {
  if (!ready) return;
  ui.errors.textContent = "";

  const raw = ui.input.value || "";
  const chars = raw.length;
  const toks0 = wordsOnlyLower(raw);
  const toks = alphaTokens(toks0);
  const nWords = toks.length;

  ui.m_chars.textContent = chars.toLocaleString();
  ui.m_words.textContent = nWords.toLocaleString();

  // Slop
  const slop = computeSlopIndex(toks);
  ui.m_slop.textContent = slop.toFixed(2);

  // Repetition score
  const toksContent = contentTokens(toks);
  const bigs = makeNgrams(toksContent, 2);
  const tris = makeNgrams(toksContent, 3);

  const topBCounts = rankOveruseWithCounts(bigs, humanBigramFreq, 40);
  const topTCounts = rankOveruseWithCounts(tris, humanTrigramFreq, 40);

  const top_bigram_count = topBCounts.reduce((s, r) => s + r[2], 0);
  const top_trigram_count = topTCounts.reduce((s, r) => s + r[2], 0);
  const total_text_length = toks.length;

  const repetition_score =
    total_text_length > 0
      ? ((top_bigram_count + top_trigram_count) / total_text_length) * 1000
      : 0;

  ui.m_rep.textContent = repetition_score.toFixed(4);

  // Contrast patterns
  const contrastResult = scoreContrast(raw);
  ui.m_contrast.textContent = contrastResult.rate_per_1k.toFixed(2);
  renderContrastMatches(ui.contrastMatches, contrastResult.matches, 10);

  // Top over-represented words (vs Zipf baseline)
  const wordCounts = countItems(toksContent);
  const wordOverrep = [];
  for (const [w, cnt] of wordCounts.entries()) {
    const zipf = lookupZipf(w);
    if (zipf === null) continue;
    const expected = Math.pow(10, zipf - 3);
    const actual = (cnt / nWords) * 1000;
    const ratio = actual / (expected + 1e-9);
    if (ratio > 1.5 && cnt >= 2) {
      wordOverrep.push([w, ratio, cnt]);
    }
  }
  wordOverrep.sort((a, b) => b[1] - a[1]);
  const topWords = wordOverrep.slice(0, 40);
  renderPills(
    ui.topWords,
    topWords.map(([w, ratio, cnt]) => [w, Number(ratio.toFixed(2))]),
    (w, v) => `<b>${w}</b> <span class="muted">${v}×</span>`,
    10
  );

  // Top bigrams and trigrams
  renderPills(
    ui.topBigrams,
    topBCounts.map(([w, ratio]) => [w, Number(ratio.toFixed(2))]),
    (w, v) => `<b>${w}</b> <span class="muted">${v}×</span>`,
    10
  );
  renderPills(
    ui.topTrigrams,
    topTCounts.map(([w, ratio]) => [w, Number(ratio.toFixed(2))]),
    (w, v) => `<b>${w}</b> <span class="muted">${v}×</span>`,
    10
  );

  // Exact phrases
  const topT = topTCounts.map(([ng, ratio, cnt]) => [ng, ratio]);
  const phrases = extractRepeatedPhrases(raw, topT, 300);
  renderPills(ui.topPhrases, phrases, (w, v) => `<b>${w}</b> <span class="muted">(${v})</span>`, 10);
});

// Prefill for quick testing
ui.input.value = `The silence wasn't empty. It wasn't absence; it was pressure. Not a pause—but a held breath.
For the first time in years, the quiet felt shared. The lattice rose, not just as metal, but as intention.`;

init();
</script>
</body>
</html>
