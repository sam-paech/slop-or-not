<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Regex Test Harness</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #1e1e1e; color: #d4d4d4; }
    h2 { color: #4ec9b0; }
    .test-case { margin: 20px 0; padding: 15px; background: #252526; border-left: 3px solid #007acc; }
    .test-case.fail { border-left-color: #f48771; }
    .test-case.pass { border-left-color: #89d185; }
    .test-input { color: #ce9178; white-space: pre-wrap; margin: 10px 0; }
    .test-result { margin: 10px 0; }
    .match { background: #264f78; padding: 2px 4px; margin: 2px; display: inline-block; }
    .error { color: #f48771; }
    .success { color: #89d185; }
    .warning { color: #dcdcaa; }
    button { background: #0e639c; color: white; border: none; padding: 8px 16px; cursor: pointer; }
    button:hover { background: #1177bb; }
    textarea { width: 100%; min-height: 100px; background: #1e1e1e; color: #d4d4d4; border: 1px solid #3c3c3c; padding: 10px; }
  </style>
</head>
<body>
  <h1>Regex Test Harness</h1>

  <div>
    <h2>Add Custom Test</h2>
    <textarea id="customInput" placeholder="Enter test text..."></textarea>
    <button onclick="runCustomTest()">Test</button>
  </div>

  <h2>Test Results</h2>
  <div id="results"></div>

<script type="module">
import { sentenceSpans } from './js/utils.js';

// Test cases
const testCases = [
  {
    name: "Valid: Not X, but Y (single sentence)",
    text: "It wasn't empty, but full.",
    patterns: ['RE_NOT_BUT'],
    expectedSentences: 1,
    shouldMatch: true
  },
  {
    name: "Valid: Not X, but Y (cross sentence - max 2)",
    text: "It wasn't empty. But it was full.",
    patterns: ['RE_NOT_BUT'],
    expectedSentences: 2,
    shouldMatch: true
  },
  {
    name: "Invalid: Not X, but Y (TOO MANY SENTENCES)",
    text: "Not just warm, but *alive*-a strange, pulsing heat that made her skin tingle. She glanced at the bench, its surface still damp from the rain, and wondered if the sneakers had been left there by a god who'd forgotten to clean them.",
    patterns: ['RE_NOT_BUT'],
    expectedSentences: 3,
    shouldMatch: false,
    reason: "Should not match across 3+ sentences"
  },
  {
    name: "Valid: VERB...sentence...VERB (max 2 sentences)",
    text: "She had always found the park strange. It was haunting.",
    taggedText: "She VERB always VERB the park strange . It VERB haunting .",
    patterns: ['RE_LEMMA_SAME_VERB'],
    expectedSentences: 2,
    shouldMatch: true
  },
  {
    name: "Invalid: VERB...VERB (TOO MANY SENTENCES)",
    text: "Aria had always found the park a strange place. It was a relic of the 1970s, a patchwork of rusted playground equipment. She loved it. Her mother hated it.",
    taggedText: "Aria VERB always VERB the park a strange place . It VERB a relic of the 1970s , a patchwork of rusted playground equipment . She VERB it . Her mother VERB it .",
    patterns: ['RE_LEMMA_SAME_VERB'],
    expectedSentences: 4,
    shouldMatch: false,
    reason: "Should not match VERBs across 4+ sentences"
  },
  {
    name: "Edge case: Multiple newlines",
    text: "It wasn't loud, but\n\nit echoed.",
    patterns: ['RE_NOT_BUT'],
    expectedSentences: 1,
    shouldMatch: true,
    reason: "Should handle newlines within single sentence"
  }
];

// Import regexes
import { STAGE1_REGEXES } from './js/regexes-stage1.js';
import { STAGE2_REGEXES } from './js/regexes-stage2.js';

const allRegexes = { ...STAGE1_REGEXES, ...STAGE2_REGEXES };

function countSentenceSpan(text, matchStart, matchEnd) {
  const spans = sentenceSpans(text);

  // Find which sentences the match covers
  let firstSent = -1, lastSent = -1;

  for (let i = 0; i < spans.length; i++) {
    const [start, end] = spans[i];

    if (firstSent === -1 && matchStart >= start && matchStart < end) {
      firstSent = i;
    }
    if (matchEnd > start && matchEnd <= end) {
      lastSent = i;
    }
  }

  if (firstSent === -1 || lastSent === -1) return null;

  return {
    sentenceCount: lastSent - firstSent + 1,
    firstSent,
    lastSent,
    sentences: spans.slice(firstSent, lastSent + 1)
  };
}

function runTest(testCase) {
  const resultsDiv = document.getElementById('results');
  const testDiv = document.createElement('div');
  testDiv.className = 'test-case';

  let html = `<h3>${testCase.name}</h3>`;
  html += `<div class="test-input">${testCase.text}</div>`;

  const textToTest = testCase.taggedText || testCase.text;

  testCase.patterns.forEach(patternName => {
    const regex = allRegexes[patternName];
    if (!regex) {
      html += `<div class="error">Pattern ${patternName} not found!</div>`;
      return;
    }

    // Reset regex
    regex.lastIndex = 0;

    const matches = Array.from(textToTest.matchAll(regex));

    html += `<div class="test-result"><strong>${patternName}:</strong> ${matches.length} match(es)</div>`;

    if (matches.length === 0) {
      if (testCase.shouldMatch) {
        html += `<div class="error">❌ Expected to match but didn't!</div>`;
        testDiv.className += ' fail';
      } else {
        html += `<div class="success">✓ Correctly did not match</div>`;
        testDiv.className += ' pass';
      }
    } else {
      matches.forEach((match, i) => {
        const spanInfo = countSentenceSpan(testCase.text, match.index, match.index + match[0].length);

        html += `<div class="match">Match ${i + 1}: "${match[0].substring(0, 60)}..."</div>`;

        if (spanInfo) {
          html += `<div>Spans ${spanInfo.sentenceCount} sentence(s)</div>`;

          if (spanInfo.sentenceCount > 2) {
            html += `<div class="error">❌ BUG: Matches across ${spanInfo.sentenceCount} sentences (max should be 2)</div>`;
            html += `<div class="warning">Reason: ${testCase.reason || 'Pattern too greedy'}</div>`;
            testDiv.className += ' fail';
          } else if (testCase.shouldMatch === false) {
            html += `<div class="error">❌ Should not have matched (${testCase.reason})</div>`;
            testDiv.className += ' fail';
          } else {
            html += `<div class="success">✓ Within acceptable range (≤2 sentences)</div>`;
            if (!testDiv.className.includes('fail')) {
              testDiv.className += ' pass';
            }
          }
        }
      });
    }
  });

  testDiv.innerHTML = html;
  resultsDiv.appendChild(testDiv);
}

function runAllTests() {
  const resultsDiv = document.getElementById('results');
  resultsDiv.innerHTML = '';

  testCases.forEach(runTest);

  // Summary
  const passed = document.querySelectorAll('.test-case.pass').length;
  const failed = document.querySelectorAll('.test-case.fail').length;

  const summary = document.createElement('div');
  summary.style.cssText = 'margin: 20px 0; padding: 15px; background: #252526; font-size: 18px;';
  summary.innerHTML = `<strong>Summary:</strong> ${passed} passed, ${failed} failed out of ${testCases.length} tests`;
  resultsDiv.insertBefore(summary, resultsDiv.firstChild);
}

window.runCustomTest = function() {
  const input = document.getElementById('customInput').value;
  if (!input) return;

  runTest({
    name: "Custom Test",
    text: input,
    patterns: Object.keys(allRegexes),
    expectedSentences: null,
    shouldMatch: null
  });
};

// Run tests on load
runAllTests();
</script>
</body>
</html>
